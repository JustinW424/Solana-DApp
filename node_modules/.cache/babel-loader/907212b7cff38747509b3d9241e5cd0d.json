{"ast":null,"code":"import camelCase from \"camelcase\";\nimport { snakeCase } from \"snake-case\";\nimport * as sha256 from \"js-sha256\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlError } from \"./error\";\n/**\n * Number of bytes of the account discriminator.\n */\n\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Namespace for state method function signatures.\n */\n\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\n\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Coder provides a facade for encoding and decoding all IDL related objects.\n */\n\nexport default class Coder {\n  constructor(idl) {\n    this.instruction = new InstructionCoder(idl);\n    this.accounts = new AccountsCoder(idl);\n    this.types = new TypesCoder(idl);\n    this.events = new EventCoder(idl);\n\n    if (idl.state) {\n      this.state = new StateCoder(idl);\n    }\n  }\n\n  sighash(nameSpace, ixName) {\n    return sighash(nameSpace, ixName);\n  }\n\n}\n/**\n * Encodes and decodes program instructions.\n */\n\nclass InstructionCoder {\n  constructor(idl) {\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n  }\n  /**\n   * Encodes a program instruction.\n   */\n\n\n  encode(ixName, ix) {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n  /**\n   * Encodes a program state instruction.\n   */\n\n\n  encodeState(ixName, ix) {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  _encode(nameSpace, ixName, ix) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n    const methodName = camelCase(ixName);\n    const len = this.ixLayout.get(methodName).encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  static parseIxLayout(idl) {\n    const stateMethods = idl.state ? idl.state.methods : [];\n    const ixLayouts = stateMethods.map(m => {\n      let fieldLayouts = m.args.map(arg => {\n        return IdlCoder.fieldLayout(arg, idl.types);\n      });\n      const name = camelCase(m.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    }).concat(idl.instructions.map(ix => {\n      let fieldLayouts = ix.args.map(arg => IdlCoder.fieldLayout(arg, idl.types));\n      const name = camelCase(ix.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    })); // @ts-ignore\n\n    return new Map(ixLayouts);\n  }\n\n}\n/**\n * Encodes and decodes account objects.\n */\n\n\nclass AccountsCoder {\n  constructor(idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n\n    const layouts = idl.accounts.map(acc => {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n    this.accountLayouts = new Map(layouts);\n  }\n\n  async encode(accountName, account) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n    const layout = this.accountLayouts.get(accountName);\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = await accountDiscriminator(accountName);\n    return Buffer.concat([discriminator, accountData]);\n  }\n\n  decode(accountName, ix) {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(8);\n    const layout = this.accountLayouts.get(accountName);\n    return layout.decode(data);\n  }\n\n}\n/**\n * Encodes and decodes user defined types.\n */\n\n\nclass TypesCoder {\n  constructor(idl) {\n    if (idl.types === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n\n    const layouts = idl.types.map(acc => {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    }); // @ts-ignore\n\n    this.layouts = new Map(layouts);\n  }\n\n  encode(accountName, account) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n    const layout = this.layouts.get(accountName);\n    const len = layout.encode(account, buffer);\n    return buffer.slice(0, len);\n  }\n\n  decode(accountName, ix) {\n    const layout = this.layouts.get(accountName);\n    return layout.decode(ix);\n  }\n\n}\n\nclass EventCoder {\n  constructor(idl) {\n    if (idl.events === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n\n    const layouts = idl.events.map(event => {\n      let eventTypeDef = {\n        name: event.name,\n        type: {\n          kind: \"struct\",\n          fields: event.fields.map(f => {\n            return {\n              name: f.name,\n              type: f.type\n            };\n          })\n        }\n      };\n      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n    }); // @ts-ignore\n\n    this.layouts = new Map(layouts);\n  }\n\n  encode(eventName, account) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n    const layout = this.layouts.get(eventName);\n    const len = layout.encode(account, buffer);\n    return buffer.slice(0, len);\n  }\n\n  decode(eventName, ix) {\n    const layout = this.layouts.get(eventName);\n    return layout.decode(ix);\n  }\n\n}\n\nclass StateCoder {\n  constructor(idl) {\n    if (idl.state === undefined) {\n      throw new Error(\"Idl state not defined.\");\n    }\n\n    this.layout = IdlCoder.typeDefLayout(idl.state.struct, idl.types);\n  }\n\n  async encode(name, account) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n    const len = this.layout.encode(account, buffer);\n    const disc = await stateDiscriminator(name);\n    const accData = buffer.slice(0, len);\n    return Buffer.concat([disc, accData]);\n  }\n\n  decode(ix) {\n    // Chop off discriminator.\n    const data = ix.slice(8);\n    return this.layout.decode(data);\n  }\n\n}\n\nclass IdlCoder {\n  static fieldLayout(field, types) {\n    const fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n\n    switch (field.type) {\n      case \"bool\":\n        {\n          return borsh.bool(fieldName);\n        }\n\n      case \"u8\":\n        {\n          return borsh.u8(fieldName);\n        }\n\n      case \"u32\":\n        {\n          return borsh.u32(fieldName);\n        }\n\n      case \"u64\":\n        {\n          return borsh.u64(fieldName);\n        }\n\n      case \"i64\":\n        {\n          return borsh.i64(fieldName);\n        }\n\n      case \"u128\":\n        {\n          return borsh.u128(fieldName);\n        }\n\n      case \"i128\":\n        {\n          return borsh.i128(fieldName);\n        }\n\n      case \"bytes\":\n        {\n          return borsh.vecU8(fieldName);\n        }\n\n      case \"string\":\n        {\n          return borsh.str(fieldName);\n        }\n\n      case \"publicKey\":\n        {\n          return borsh.publicKey(fieldName);\n        }\n      // TODO: all the other types that need to be exported by the borsh package.\n\n      default:\n        {\n          // @ts-ignore\n          if (field.type.vec) {\n            return borsh.vec(IdlCoder.fieldLayout({\n              name: undefined,\n              // @ts-ignore\n              type: field.type.vec\n            }, types), fieldName); // @ts-ignore\n          } else if (field.type.option) {\n            return borsh.option(IdlCoder.fieldLayout({\n              name: undefined,\n              // @ts-ignore\n              type: field.type.option\n            }, types), fieldName); // @ts-ignore\n          } else if (field.type.defined) {\n            // User defined type.\n            if (types === undefined) {\n              throw new IdlError(\"User defined types not provided\");\n            } // @ts-ignore\n\n\n            const filtered = types.filter(t => t.name === field.type.defined);\n\n            if (filtered.length !== 1) {\n              throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n            }\n\n            return IdlCoder.typeDefLayout(filtered[0], types, fieldName); // @ts-ignore\n          } else if (field.type.array) {\n            // @ts-ignore\n            let arrayTy = field.type.array[0]; // @ts-ignore\n\n            let arrayLen = field.type.array[1];\n            let innerLayout = IdlCoder.fieldLayout({\n              name: undefined,\n              type: arrayTy\n            }, types);\n            return borsh.array(innerLayout, arrayLen, fieldName);\n          } else {\n            throw new Error(`Not yet implemented: ${field}`);\n          }\n        }\n    }\n  }\n\n  static typeDefLayout(typeDef, types, name) {\n    if (typeDef.type.kind === \"struct\") {\n      const fieldLayouts = typeDef.type.fields.map(field => {\n        const x = IdlCoder.fieldLayout(field, types);\n        return x;\n      });\n      return borsh.struct(fieldLayouts, name);\n    } else if (typeDef.type.kind === \"enum\") {\n      let variants = typeDef.type.variants.map(variant => {\n        const name = camelCase(variant.name);\n\n        if (variant.fields === undefined) {\n          return borsh.struct([], name);\n        } // @ts-ignore\n\n\n        const fieldLayouts = variant.fields.map(f => {\n          // @ts-ignore\n          if (f.name === undefined) {\n            throw new Error(\"Tuple enum variants not yet implemented.\");\n          } // @ts-ignore\n\n\n          return IdlCoder.fieldLayout(f, types);\n        });\n        return borsh.struct(fieldLayouts, name);\n      });\n\n      if (name !== undefined) {\n        // Buffer-layout lib requires the name to be null (on construction)\n        // when used as a field.\n        return borsh.rustEnum(variants).replicate(name);\n      }\n\n      return borsh.rustEnum(variants, name);\n    } else {\n      throw new Error(`Unknown type kint: ${typeDef}`);\n    }\n  }\n\n} // Calculates unique 8 byte discriminator prepended to all anchor accounts.\n\n\nexport async function accountDiscriminator(name) {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n} // Calculates unique 8 byte discriminator prepended to all anchor state accounts.\n\nexport async function stateDiscriminator(name) {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\nexport function eventDiscriminator(name) {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`event:${name}`)).slice(0, 8);\n} // Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\n\nfunction typeSize(idl, ty) {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n\n    case \"u8\":\n      return 1;\n\n    case \"i8\":\n      return 1;\n\n    case \"u16\":\n      return 2;\n\n    case \"u32\":\n      return 4;\n\n    case \"u64\":\n      return 8;\n\n    case \"i64\":\n      return 8;\n\n    case \"u128\":\n      return 16;\n\n    case \"i128\":\n      return 16;\n\n    case \"bytes\":\n      return 1;\n\n    case \"string\":\n      return 1;\n\n    case \"publicKey\":\n      return 32;\n\n    default:\n      // @ts-ignore\n      if (ty.vec !== undefined) {\n        return 1;\n      } // @ts-ignore\n\n\n      if (ty.option !== undefined) {\n        // @ts-ignore\n        return 1 + typeSize(idl, ty.option);\n      } // @ts-ignore\n\n\n      if (ty.defined !== undefined) {\n        // @ts-ignore\n        const filtered = idl.types.filter(t => t.name === ty.defined);\n\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n\n        let typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      } // @ts-ignore\n\n\n      if (ty.array !== undefined) {\n        // @ts-ignore\n        let arrayTy = ty.array[0]; // @ts-ignore\n\n        let arraySize = ty.array[1]; // @ts-ignore\n\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n}\n\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(variant => {\n      if (variant.fields === undefined) {\n        return 0;\n      } // @ts-ignore\n\n\n      return variant.fields // @ts-ignore\n      .map(f => {\n        // @ts-ignore\n        if (f.name === undefined) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        } // @ts-ignore\n\n\n        return typeSize(idl, f.type);\n      }).reduce((a, b) => a + b);\n    });\n    return Math.max(...variantSizes) + 1;\n  }\n\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n\n  return idlAccount.type.fields.map(f => typeSize(idl, f.type)).reduce((a, b) => a + b);\n} // Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\n\nfunction sighash(nameSpace, ixName) {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}::${name}`; // @ts-ignore\n\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"sources":["../../src/coder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport { snakeCase } from \"snake-case\";\nimport * as sha256 from \"js-sha256\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlError } from \"./error\";\n/**\n * Number of bytes of the account discriminator.\n */\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Coder provides a facade for encoding and decoding all IDL related objects.\n */\nexport default class Coder {\n    constructor(idl) {\n        this.instruction = new InstructionCoder(idl);\n        this.accounts = new AccountsCoder(idl);\n        this.types = new TypesCoder(idl);\n        this.events = new EventCoder(idl);\n        if (idl.state) {\n            this.state = new StateCoder(idl);\n        }\n    }\n    sighash(nameSpace, ixName) {\n        return sighash(nameSpace, ixName);\n    }\n}\n/**\n * Encodes and decodes program instructions.\n */\nclass InstructionCoder {\n    constructor(idl) {\n        this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    }\n    /**\n     * Encodes a program instruction.\n     */\n    encode(ixName, ix) {\n        return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n    encodeState(ixName, ix) {\n        return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n    _encode(nameSpace, ixName, ix) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const methodName = camelCase(ixName);\n        const len = this.ixLayout.get(methodName).encode(ix, buffer);\n        const data = buffer.slice(0, len);\n        return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n    static parseIxLayout(idl) {\n        const stateMethods = idl.state ? idl.state.methods : [];\n        const ixLayouts = stateMethods\n            .map((m) => {\n            let fieldLayouts = m.args.map((arg) => {\n                return IdlCoder.fieldLayout(arg, idl.types);\n            });\n            const name = camelCase(m.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        })\n            .concat(idl.instructions.map((ix) => {\n            let fieldLayouts = ix.args.map((arg) => IdlCoder.fieldLayout(arg, idl.types));\n            const name = camelCase(ix.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        }));\n        // @ts-ignore\n        return new Map(ixLayouts);\n    }\n}\n/**\n * Encodes and decodes account objects.\n */\nclass AccountsCoder {\n    constructor(idl) {\n        if (idl.accounts === undefined) {\n            this.accountLayouts = new Map();\n            return;\n        }\n        const layouts = idl.accounts.map((acc) => {\n            return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n        });\n        this.accountLayouts = new Map(layouts);\n    }\n    async encode(accountName, account) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.accountLayouts.get(accountName);\n        const len = layout.encode(account, buffer);\n        let accountData = buffer.slice(0, len);\n        let discriminator = await accountDiscriminator(accountName);\n        return Buffer.concat([discriminator, accountData]);\n    }\n    decode(accountName, ix) {\n        // Chop off the discriminator before decoding.\n        const data = ix.slice(8);\n        const layout = this.accountLayouts.get(accountName);\n        return layout.decode(data);\n    }\n}\n/**\n * Encodes and decodes user defined types.\n */\nclass TypesCoder {\n    constructor(idl) {\n        if (idl.types === undefined) {\n            this.layouts = new Map();\n            return;\n        }\n        const layouts = idl.types.map((acc) => {\n            return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n        });\n        // @ts-ignore\n        this.layouts = new Map(layouts);\n    }\n    encode(accountName, account) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.layouts.get(accountName);\n        const len = layout.encode(account, buffer);\n        return buffer.slice(0, len);\n    }\n    decode(accountName, ix) {\n        const layout = this.layouts.get(accountName);\n        return layout.decode(ix);\n    }\n}\nclass EventCoder {\n    constructor(idl) {\n        if (idl.events === undefined) {\n            this.layouts = new Map();\n            return;\n        }\n        const layouts = idl.events.map((event) => {\n            let eventTypeDef = {\n                name: event.name,\n                type: {\n                    kind: \"struct\",\n                    fields: event.fields.map((f) => {\n                        return { name: f.name, type: f.type };\n                    }),\n                },\n            };\n            return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n        });\n        // @ts-ignore\n        this.layouts = new Map(layouts);\n    }\n    encode(eventName, account) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.layouts.get(eventName);\n        const len = layout.encode(account, buffer);\n        return buffer.slice(0, len);\n    }\n    decode(eventName, ix) {\n        const layout = this.layouts.get(eventName);\n        return layout.decode(ix);\n    }\n}\nclass StateCoder {\n    constructor(idl) {\n        if (idl.state === undefined) {\n            throw new Error(\"Idl state not defined.\");\n        }\n        this.layout = IdlCoder.typeDefLayout(idl.state.struct, idl.types);\n    }\n    async encode(name, account) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const len = this.layout.encode(account, buffer);\n        const disc = await stateDiscriminator(name);\n        const accData = buffer.slice(0, len);\n        return Buffer.concat([disc, accData]);\n    }\n    decode(ix) {\n        // Chop off discriminator.\n        const data = ix.slice(8);\n        return this.layout.decode(data);\n    }\n}\nclass IdlCoder {\n    static fieldLayout(field, types) {\n        const fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n        switch (field.type) {\n            case \"bool\": {\n                return borsh.bool(fieldName);\n            }\n            case \"u8\": {\n                return borsh.u8(fieldName);\n            }\n            case \"u32\": {\n                return borsh.u32(fieldName);\n            }\n            case \"u64\": {\n                return borsh.u64(fieldName);\n            }\n            case \"i64\": {\n                return borsh.i64(fieldName);\n            }\n            case \"u128\": {\n                return borsh.u128(fieldName);\n            }\n            case \"i128\": {\n                return borsh.i128(fieldName);\n            }\n            case \"bytes\": {\n                return borsh.vecU8(fieldName);\n            }\n            case \"string\": {\n                return borsh.str(fieldName);\n            }\n            case \"publicKey\": {\n                return borsh.publicKey(fieldName);\n            }\n            // TODO: all the other types that need to be exported by the borsh package.\n            default: {\n                // @ts-ignore\n                if (field.type.vec) {\n                    return borsh.vec(IdlCoder.fieldLayout({\n                        name: undefined,\n                        // @ts-ignore\n                        type: field.type.vec,\n                    }, types), fieldName);\n                    // @ts-ignore\n                }\n                else if (field.type.option) {\n                    return borsh.option(IdlCoder.fieldLayout({\n                        name: undefined,\n                        // @ts-ignore\n                        type: field.type.option,\n                    }, types), fieldName);\n                    // @ts-ignore\n                }\n                else if (field.type.defined) {\n                    // User defined type.\n                    if (types === undefined) {\n                        throw new IdlError(\"User defined types not provided\");\n                    }\n                    // @ts-ignore\n                    const filtered = types.filter((t) => t.name === field.type.defined);\n                    if (filtered.length !== 1) {\n                        throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n                    }\n                    return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n                    // @ts-ignore\n                }\n                else if (field.type.array) {\n                    // @ts-ignore\n                    let arrayTy = field.type.array[0];\n                    // @ts-ignore\n                    let arrayLen = field.type.array[1];\n                    let innerLayout = IdlCoder.fieldLayout({\n                        name: undefined,\n                        type: arrayTy,\n                    }, types);\n                    return borsh.array(innerLayout, arrayLen, fieldName);\n                }\n                else {\n                    throw new Error(`Not yet implemented: ${field}`);\n                }\n            }\n        }\n    }\n    static typeDefLayout(typeDef, types, name) {\n        if (typeDef.type.kind === \"struct\") {\n            const fieldLayouts = typeDef.type.fields.map((field) => {\n                const x = IdlCoder.fieldLayout(field, types);\n                return x;\n            });\n            return borsh.struct(fieldLayouts, name);\n        }\n        else if (typeDef.type.kind === \"enum\") {\n            let variants = typeDef.type.variants.map((variant) => {\n                const name = camelCase(variant.name);\n                if (variant.fields === undefined) {\n                    return borsh.struct([], name);\n                }\n                // @ts-ignore\n                const fieldLayouts = variant.fields.map((f) => {\n                    // @ts-ignore\n                    if (f.name === undefined) {\n                        throw new Error(\"Tuple enum variants not yet implemented.\");\n                    }\n                    // @ts-ignore\n                    return IdlCoder.fieldLayout(f, types);\n                });\n                return borsh.struct(fieldLayouts, name);\n            });\n            if (name !== undefined) {\n                // Buffer-layout lib requires the name to be null (on construction)\n                // when used as a field.\n                return borsh.rustEnum(variants).replicate(name);\n            }\n            return borsh.rustEnum(variants, name);\n        }\n        else {\n            throw new Error(`Unknown type kint: ${typeDef}`);\n        }\n    }\n}\n// Calculates unique 8 byte discriminator prepended to all anchor accounts.\nexport async function accountDiscriminator(name) {\n    // @ts-ignore\n    return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\n// Calculates unique 8 byte discriminator prepended to all anchor state accounts.\nexport async function stateDiscriminator(name) {\n    // @ts-ignore\n    return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\nexport function eventDiscriminator(name) {\n    // @ts-ignore\n    return Buffer.from(sha256.digest(`event:${name}`)).slice(0, 8);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n    switch (ty) {\n        case \"bool\":\n            return 1;\n        case \"u8\":\n            return 1;\n        case \"i8\":\n            return 1;\n        case \"u16\":\n            return 2;\n        case \"u32\":\n            return 4;\n        case \"u64\":\n            return 8;\n        case \"i64\":\n            return 8;\n        case \"u128\":\n            return 16;\n        case \"i128\":\n            return 16;\n        case \"bytes\":\n            return 1;\n        case \"string\":\n            return 1;\n        case \"publicKey\":\n            return 32;\n        default:\n            // @ts-ignore\n            if (ty.vec !== undefined) {\n                return 1;\n            }\n            // @ts-ignore\n            if (ty.option !== undefined) {\n                // @ts-ignore\n                return 1 + typeSize(idl, ty.option);\n            }\n            // @ts-ignore\n            if (ty.defined !== undefined) {\n                // @ts-ignore\n                const filtered = idl.types.filter((t) => t.name === ty.defined);\n                if (filtered.length !== 1) {\n                    throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n                }\n                let typeDef = filtered[0];\n                return accountSize(idl, typeDef);\n            }\n            // @ts-ignore\n            if (ty.array !== undefined) {\n                // @ts-ignore\n                let arrayTy = ty.array[0];\n                // @ts-ignore\n                let arraySize = ty.array[1];\n                // @ts-ignore\n                return typeSize(idl, arrayTy) * arraySize;\n            }\n            throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n    }\n}\nexport function accountSize(idl, idlAccount) {\n    if (idlAccount.type.kind === \"enum\") {\n        let variantSizes = idlAccount.type.variants.map((variant) => {\n            if (variant.fields === undefined) {\n                return 0;\n            }\n            // @ts-ignore\n            return (variant.fields\n                // @ts-ignore\n                .map((f) => {\n                // @ts-ignore\n                if (f.name === undefined) {\n                    throw new Error(\"Tuple enum variants not yet implemented.\");\n                }\n                // @ts-ignore\n                return typeSize(idl, f.type);\n            })\n                .reduce((a, b) => a + b));\n        });\n        return Math.max(...variantSizes) + 1;\n    }\n    if (idlAccount.type.fields === undefined) {\n        return 0;\n    }\n    return idlAccount.type.fields\n        .map((f) => typeSize(idl, f.type))\n        .reduce((a, b) => a + b);\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace, ixName) {\n    let name = snakeCase(ixName);\n    let preimage = `${nameSpace}::${name}`;\n    // @ts-ignore\n    return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n//# sourceMappingURL=coder.js.map"]},"metadata":{},"sourceType":"module"}