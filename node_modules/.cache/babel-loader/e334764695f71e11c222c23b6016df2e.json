{"ast":null,"code":"import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { PublicKey, SystemProgram, Transaction, TransactionInstruction, SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\nimport { IdlError, ProgramError } from \"./error\";\nimport { ACCOUNT_DISCRIMINATOR_SIZE, accountDiscriminator, stateDiscriminator, accountSize } from \"./coder\"; // Tracks all subscriptions.\n\nconst subscriptions = new Map();\n/**\n * RpcFactory builds an Rpcs object for a given IDL.\n */\n\nexport class RpcFactory {\n  /**\n   * build dynamically generates RPC methods.\n   *\n   * @returns an object with all the RPC methods attached.\n   */\n  static build(idl, coder, programId, provider) {\n    const idlErrors = parseIdlErrors(idl);\n    const rpcs = {};\n    const ixFns = {};\n    const txFns = {};\n    const state = RpcFactory.buildState(idl, coder, programId, idlErrors, provider);\n    idl.instructions.forEach(idlIx => {\n      const name = camelCase(idlIx.name); // Function to create a raw `TransactionInstruction`.\n\n      const ix = RpcFactory.buildIx(idlIx, coder, programId); // Ffnction to create a `Transaction`.\n\n      const tx = RpcFactory.buildTx(idlIx, ix); // Function to invoke an RPC against a cluster.\n\n      const rpc = RpcFactory.buildRpc(idlIx, tx, idlErrors, provider);\n      rpcs[name] = rpc;\n      ixFns[name] = ix;\n      txFns[name] = tx;\n    });\n    const accountFns = idl.accounts ? RpcFactory.buildAccounts(idl, coder, programId, provider) : {};\n    return [rpcs, ixFns, txFns, accountFns, state];\n  } // Builds the state namespace.\n\n\n  static buildState(idl, coder, programId, idlErrors, provider) {\n    if (idl.state === undefined) {\n      return undefined;\n    } // Fetches the state object from the blockchain.\n\n\n    const state = async () => {\n      const addr = await programStateAddress(programId);\n      const accountInfo = await provider.connection.getAccountInfo(addr);\n\n      if (accountInfo === null) {\n        throw new Error(`Account does not exist ${addr.toString()}`);\n      } // Assert the account discriminator is correct.\n\n\n      const expectedDiscriminator = await stateDiscriminator(idl.state.struct.name);\n\n      if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n        throw new Error(\"Invalid account discriminator\");\n      }\n\n      return coder.state.decode(accountInfo.data);\n    }; // Namespace with all rpc functions.\n\n\n    const rpc = {};\n    const ix = {};\n    idl.state.methods.forEach(m => {\n      const accounts = async accounts => {\n        const keys = await stateInstructionKeys(programId, provider, m, accounts);\n        return keys.concat(RpcFactory.accountsArray(accounts, m.accounts));\n      };\n\n      const ixFn = async function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        const [ixArgs, ctx] = splitArgsAndCtx(m, [...args]);\n        return new TransactionInstruction({\n          keys: await accounts(ctx.accounts),\n          programId,\n          data: coder.instruction.encodeState(m.name, toInstruction(m, ...ixArgs))\n        });\n      };\n\n      ixFn[\"accounts\"] = accounts;\n      ix[m.name] = ixFn;\n\n      rpc[m.name] = async function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        const [_, ctx] = splitArgsAndCtx(m, [...args]);\n        const tx = new Transaction();\n\n        if (ctx.instructions !== undefined) {\n          tx.add(...ctx.instructions);\n        }\n\n        tx.add(await ix[m.name](...args));\n\n        try {\n          const txSig = await provider.send(tx, ctx.signers, ctx.options);\n          return txSig;\n        } catch (err) {\n          let translatedErr = translateError(idlErrors, err);\n\n          if (translatedErr === null) {\n            throw err;\n          }\n\n          throw translatedErr;\n        }\n      };\n    });\n    state[\"rpc\"] = rpc;\n    state[\"instruction\"] = ix; // Calculates the address of the program's global state object account.\n\n    state[\"address\"] = async () => programStateAddress(programId); // Subscription singleton.\n\n\n    let sub = null; // Subscribe to account changes.\n\n    state[\"subscribe\"] = commitment => {\n      if (sub !== null) {\n        return sub.ee;\n      }\n\n      const ee = new EventEmitter();\n      state[\"address\"]().then(address => {\n        const listener = provider.connection.onAccountChange(address, acc => {\n          const account = coder.state.decode(acc.data);\n          ee.emit(\"change\", account);\n        }, commitment);\n        sub = {\n          ee,\n          listener\n        };\n      });\n      return ee;\n    }; // Unsubscribe from account changes.\n\n\n    state[\"unsubscribe\"] = () => {\n      if (sub !== null) {\n        provider.connection.removeAccountChangeListener(sub.listener).then(async () => {\n          sub = null;\n        }).catch(console.error);\n      }\n    };\n\n    return state;\n  } // Builds the instuction namespace.\n\n\n  static buildIx(idlIx, coder, programId) {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n      const keys = RpcFactory.accountsArray(ctx.accounts, idlIx.accounts);\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (ctx.__private && ctx.__private.logAccounts) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: coder.instruction.encode(idlIx.name, toInstruction(idlIx, ...ixArgs))\n      });\n    }; // Utility fn for ordering the accounts for this instruction.\n\n\n    ix[\"accounts\"] = accs => {\n      return RpcFactory.accountsArray(accs, idlIx.accounts);\n    };\n\n    return ix;\n  }\n\n  static accountsArray(ctx, accounts) {\n    return accounts.map(acc => {\n      // Nested accounts.\n      // @ts-ignore\n      const nestedAccounts = acc.accounts;\n\n      if (nestedAccounts !== undefined) {\n        const rpcAccs = ctx[acc.name];\n        return RpcFactory.accountsArray(rpcAccs, nestedAccounts).flat();\n      } else {\n        const account = acc;\n        return {\n          pubkey: ctx[acc.name],\n          isWritable: account.isMut,\n          isSigner: account.isSigner\n        };\n      }\n    }).flat();\n  } // Builds the rpc namespace.\n\n\n  static buildRpc(idlIx, txFn, idlErrors, provider) {\n    const rpc = async function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      const tx = txFn(...args);\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n\n      try {\n        const txSig = await provider.send(tx, ctx.signers, ctx.options);\n        return txSig;\n      } catch (err) {\n        console.log(\"Translating error\", err);\n        let translatedErr = translateError(idlErrors, err);\n\n        if (translatedErr === null) {\n          throw err;\n        }\n\n        throw translatedErr;\n      }\n    };\n\n    return rpc;\n  } // Builds the transaction namespace.\n\n\n  static buildTx(idlIx, ixFn) {\n    const txFn = function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      const tx = new Transaction();\n\n      if (ctx.instructions !== undefined) {\n        tx.add(...ctx.instructions);\n      }\n\n      tx.add(ixFn(...args));\n      return tx;\n    };\n\n    return txFn;\n  } // Returns the generated accounts namespace.\n\n\n  static buildAccounts(idl, coder, programId, provider) {\n    const accountFns = {};\n    idl.accounts.forEach(idlAccount => {\n      const name = camelCase(idlAccount.name); // Fetches the decoded account from the network.\n\n      const accountsNamespace = async address => {\n        const accountInfo = await provider.connection.getAccountInfo(address);\n\n        if (accountInfo === null) {\n          throw new Error(`Account does not exist ${address.toString()}`);\n        } // Assert the account discriminator is correct.\n\n\n        const discriminator = await accountDiscriminator(idlAccount.name);\n\n        if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n          throw new Error(\"Invalid account discriminator\");\n        }\n\n        return coder.accounts.decode(idlAccount.name, accountInfo.data);\n      }; // Returns the size of the account.\n      // @ts-ignore\n\n\n      accountsNamespace[\"size\"] = ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount); // Returns an instruction for creating this account.\n      // @ts-ignore\n\n      accountsNamespace[\"createInstruction\"] = async (account, sizeOverride) => {\n        // @ts-ignore\n        const size = accountsNamespace[\"size\"];\n        return SystemProgram.createAccount({\n          fromPubkey: provider.wallet.publicKey,\n          newAccountPubkey: account.publicKey,\n          space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n          lamports: await provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n          programId\n        });\n      }; // Subscribes to all changes to this account.\n      // @ts-ignore\n\n\n      accountsNamespace[\"subscribe\"] = (address, commitment) => {\n        if (subscriptions.get(address.toString())) {\n          return subscriptions.get(address.toString()).ee;\n        }\n\n        const ee = new EventEmitter();\n        const listener = provider.connection.onAccountChange(address, acc => {\n          const account = coder.accounts.decode(idlAccount.name, acc.data);\n          ee.emit(\"change\", account);\n        }, commitment);\n        subscriptions.set(address.toString(), {\n          ee,\n          listener\n        });\n        return ee;\n      }; // Unsubscribes to account changes.\n      // @ts-ignore\n\n\n      accountsNamespace[\"unsubscribe\"] = address => {\n        let sub = subscriptions.get(address.toString());\n\n        if (!sub) {\n          console.warn(\"Address is not subscribed\");\n          return;\n        }\n\n        if (subscriptions) {\n          provider.connection.removeAccountChangeListener(sub.listener).then(() => {\n            subscriptions.delete(address.toString());\n          }).catch(console.error);\n        }\n      }; // Returns all instances of this account type for the program.\n      // @ts-ignore\n\n\n      accountsNamespace[\"all\"] = async filter => {\n        let bytes = await accountDiscriminator(idlAccount.name);\n\n        if (filter !== undefined) {\n          bytes = Buffer.concat([bytes, filter]);\n        } // @ts-ignore\n\n\n        let resp = await provider.connection._rpcRequest(\"getProgramAccounts\", [programId.toBase58(), {\n          commitment: provider.connection.commitment,\n          filters: [{\n            memcmp: {\n              offset: 0,\n              bytes: bs58.encode(bytes)\n            }\n          }],\n          encoding: 'base64'\n        }]);\n\n        if (resp.error) {\n          console.error(resp);\n          throw new Error(\"Failed to get accounts\");\n        }\n\n        return resp.result.map(_ref => {\n          let {\n            pubkey,\n            account: {\n              data\n            }\n          } = _ref;\n          data = bs58.decode(bs58.encode(Uint8Array.from(atob(data[0]), c => c.charCodeAt(0))));\n          return {\n            publicKey: new PublicKey(pubkey),\n            account: coder.accounts.decode(idlAccount.name, data)\n          };\n        });\n      }; // Function returning the associated address. Args are keys to associate.\n      // Order matters.\n\n\n      accountsNamespace[\"associatedAddress\"] = async function () {\n        let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n\n        args.forEach(arg => {\n          seeds.push(arg.toBuffer());\n        });\n        const [assoc] = await PublicKey.findProgramAddress(seeds, programId);\n        return assoc;\n      }; // Function returning the associated account. Args are keys to associate.\n      // Order matters.\n\n\n      accountsNamespace[\"associated\"] = async function () {\n        const addr = await accountsNamespace[\"associatedAddress\"](...arguments);\n        return await accountsNamespace(addr);\n      };\n\n      accountFns[name] = accountsNamespace;\n    });\n    return accountFns;\n  }\n\n}\n\nfunction translateError(idlErrors, err) {\n  // TODO: don't rely on the error string. web3.js should preserve the error\n  //       code information instead of giving us an untyped string.\n  let components = err.toString().split(\"custom program error: \");\n\n  if (components.length === 2) {\n    try {\n      const errorCode = parseInt(components[1]);\n      let errorMsg = idlErrors.get(errorCode);\n\n      if (errorMsg === undefined) {\n        // Unexpected error code so just throw the untranslated error.\n        return null;\n      }\n\n      return new ProgramError(errorCode, errorMsg);\n    } catch (parseErr) {\n      // Unable to parse the error. Just return the untranslated error.\n      return null;\n    }\n  }\n}\n\nfunction parseIdlErrors(idl) {\n  const errors = new Map();\n\n  if (idl.errors) {\n    idl.errors.forEach(e => {\n      var _a;\n\n      let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n      errors.set(e.code, msg);\n    });\n  }\n\n  return errors;\n}\n\nfunction splitArgsAndCtx(idlIx, args) {\n  let options = {};\n  const inputLen = idlIx.args ? idlIx.args.length : 0;\n\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(\"provided too many arguments ${args}\");\n    }\n\n    options = args.pop();\n  }\n\n  return [args, options];\n} // Allow either IdLInstruction or IdlStateMethod since the types share fields.\n\n\nfunction toInstruction(idlIx) {\n  for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    args[_key7 - 1] = arguments[_key7];\n  }\n\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n\n  const ix = {};\n  let idx = 0;\n  idlIx.args.forEach(ixArg => {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n  return ix;\n} // Throws error if any account required for the `ix` is not given.\n\n\nfunction validateAccounts(ixAccounts, accounts) {\n  ixAccounts.forEach(acc => {\n    // @ts-ignore\n    if (acc.accounts !== undefined) {\n      // @ts-ignore\n      validateAccounts(acc.accounts, accounts[acc.name]);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(`Invalid arguments: ${acc.name} not provided.`);\n      }\n    }\n  });\n} // Throws error if any argument required for the `ix` is not given.\n\n\nfunction validateInstruction(ix) {// todo\n} // Calculates the deterministic address of the program's \"state\" account.\n\n\nasync function programStateAddress(programId) {\n  let [registrySigner, _nonce] = await PublicKey.findProgramAddress([], programId);\n  return PublicKey.createWithSeed(registrySigner, \"unversioned\", programId);\n} // Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\n\n\nasync function stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner, _nonce] = await PublicKey.findProgramAddress([], programId);\n    return [{\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: await programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [{\n      pubkey: await programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"sources":["../../src/rpc.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { PublicKey, SystemProgram, Transaction, TransactionInstruction, SYSVAR_RENT_PUBKEY, } from \"@solana/web3.js\";\nimport { IdlError, ProgramError } from \"./error\";\nimport { ACCOUNT_DISCRIMINATOR_SIZE, accountDiscriminator, stateDiscriminator, accountSize, } from \"./coder\";\n// Tracks all subscriptions.\nconst subscriptions = new Map();\n/**\n * RpcFactory builds an Rpcs object for a given IDL.\n */\nexport class RpcFactory {\n    /**\n     * build dynamically generates RPC methods.\n     *\n     * @returns an object with all the RPC methods attached.\n     */\n    static build(idl, coder, programId, provider) {\n        const idlErrors = parseIdlErrors(idl);\n        const rpcs = {};\n        const ixFns = {};\n        const txFns = {};\n        const state = RpcFactory.buildState(idl, coder, programId, idlErrors, provider);\n        idl.instructions.forEach((idlIx) => {\n            const name = camelCase(idlIx.name);\n            // Function to create a raw `TransactionInstruction`.\n            const ix = RpcFactory.buildIx(idlIx, coder, programId);\n            // Ffnction to create a `Transaction`.\n            const tx = RpcFactory.buildTx(idlIx, ix);\n            // Function to invoke an RPC against a cluster.\n            const rpc = RpcFactory.buildRpc(idlIx, tx, idlErrors, provider);\n            rpcs[name] = rpc;\n            ixFns[name] = ix;\n            txFns[name] = tx;\n        });\n        const accountFns = idl.accounts\n            ? RpcFactory.buildAccounts(idl, coder, programId, provider)\n            : {};\n        return [rpcs, ixFns, txFns, accountFns, state];\n    }\n    // Builds the state namespace.\n    static buildState(idl, coder, programId, idlErrors, provider) {\n        if (idl.state === undefined) {\n            return undefined;\n        }\n        // Fetches the state object from the blockchain.\n        const state = async () => {\n            const addr = await programStateAddress(programId);\n            const accountInfo = await provider.connection.getAccountInfo(addr);\n            if (accountInfo === null) {\n                throw new Error(`Account does not exist ${addr.toString()}`);\n            }\n            // Assert the account discriminator is correct.\n            const expectedDiscriminator = await stateDiscriminator(idl.state.struct.name);\n            if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n                throw new Error(\"Invalid account discriminator\");\n            }\n            return coder.state.decode(accountInfo.data);\n        };\n        // Namespace with all rpc functions.\n        const rpc = {};\n        const ix = {};\n        idl.state.methods.forEach((m) => {\n            const accounts = async (accounts) => {\n                const keys = await stateInstructionKeys(programId, provider, m, accounts);\n                return keys.concat(RpcFactory.accountsArray(accounts, m.accounts));\n            };\n            const ixFn = async (...args) => {\n                const [ixArgs, ctx] = splitArgsAndCtx(m, [...args]);\n                return new TransactionInstruction({\n                    keys: await accounts(ctx.accounts),\n                    programId,\n                    data: coder.instruction.encodeState(m.name, toInstruction(m, ...ixArgs)),\n                });\n            };\n            ixFn[\"accounts\"] = accounts;\n            ix[m.name] = ixFn;\n            rpc[m.name] = async (...args) => {\n                const [_, ctx] = splitArgsAndCtx(m, [...args]);\n                const tx = new Transaction();\n                if (ctx.instructions !== undefined) {\n                    tx.add(...ctx.instructions);\n                }\n                tx.add(await ix[m.name](...args));\n                try {\n                    const txSig = await provider.send(tx, ctx.signers, ctx.options);\n                    return txSig;\n                }\n                catch (err) {\n                    let translatedErr = translateError(idlErrors, err);\n                    if (translatedErr === null) {\n                        throw err;\n                    }\n                    throw translatedErr;\n                }\n            };\n        });\n        state[\"rpc\"] = rpc;\n        state[\"instruction\"] = ix;\n        // Calculates the address of the program's global state object account.\n        state[\"address\"] = async () => programStateAddress(programId);\n        // Subscription singleton.\n        let sub = null;\n        // Subscribe to account changes.\n        state[\"subscribe\"] = (commitment) => {\n            if (sub !== null) {\n                return sub.ee;\n            }\n            const ee = new EventEmitter();\n            state[\"address\"]().then((address) => {\n                const listener = provider.connection.onAccountChange(address, (acc) => {\n                    const account = coder.state.decode(acc.data);\n                    ee.emit(\"change\", account);\n                }, commitment);\n                sub = {\n                    ee,\n                    listener,\n                };\n            });\n            return ee;\n        };\n        // Unsubscribe from account changes.\n        state[\"unsubscribe\"] = () => {\n            if (sub !== null) {\n                provider.connection\n                    .removeAccountChangeListener(sub.listener)\n                    .then(async () => {\n                    sub = null;\n                })\n                    .catch(console.error);\n            }\n        };\n        return state;\n    }\n    // Builds the instuction namespace.\n    static buildIx(idlIx, coder, programId) {\n        if (idlIx.name === \"_inner\") {\n            throw new IdlError(\"the _inner name is reserved\");\n        }\n        const ix = (...args) => {\n            const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            validateAccounts(idlIx.accounts, ctx.accounts);\n            validateInstruction(idlIx, ...args);\n            const keys = RpcFactory.accountsArray(ctx.accounts, idlIx.accounts);\n            if (ctx.remainingAccounts !== undefined) {\n                keys.push(...ctx.remainingAccounts);\n            }\n            if (ctx.__private && ctx.__private.logAccounts) {\n                console.log(\"Outgoing account metas:\", keys);\n            }\n            return new TransactionInstruction({\n                keys,\n                programId,\n                data: coder.instruction.encode(idlIx.name, toInstruction(idlIx, ...ixArgs)),\n            });\n        };\n        // Utility fn for ordering the accounts for this instruction.\n        ix[\"accounts\"] = (accs) => {\n            return RpcFactory.accountsArray(accs, idlIx.accounts);\n        };\n        return ix;\n    }\n    static accountsArray(ctx, accounts) {\n        return accounts\n            .map((acc) => {\n            // Nested accounts.\n            // @ts-ignore\n            const nestedAccounts = acc.accounts;\n            if (nestedAccounts !== undefined) {\n                const rpcAccs = ctx[acc.name];\n                return RpcFactory.accountsArray(rpcAccs, nestedAccounts).flat();\n            }\n            else {\n                const account = acc;\n                return {\n                    pubkey: ctx[acc.name],\n                    isWritable: account.isMut,\n                    isSigner: account.isSigner,\n                };\n            }\n        })\n            .flat();\n    }\n    // Builds the rpc namespace.\n    static buildRpc(idlIx, txFn, idlErrors, provider) {\n        const rpc = async (...args) => {\n            const tx = txFn(...args);\n            const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            try {\n                const txSig = await provider.send(tx, ctx.signers, ctx.options);\n                return txSig;\n            }\n            catch (err) {\n                console.log(\"Translating error\", err);\n                let translatedErr = translateError(idlErrors, err);\n                if (translatedErr === null) {\n                    throw err;\n                }\n                throw translatedErr;\n            }\n        };\n        return rpc;\n    }\n    // Builds the transaction namespace.\n    static buildTx(idlIx, ixFn) {\n        const txFn = (...args) => {\n            const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            const tx = new Transaction();\n            if (ctx.instructions !== undefined) {\n                tx.add(...ctx.instructions);\n            }\n            tx.add(ixFn(...args));\n            return tx;\n        };\n        return txFn;\n    }\n    // Returns the generated accounts namespace.\n    static buildAccounts(idl, coder, programId, provider) {\n        const accountFns = {};\n        idl.accounts.forEach((idlAccount) => {\n            const name = camelCase(idlAccount.name);\n            // Fetches the decoded account from the network.\n            const accountsNamespace = async (address) => {\n                const accountInfo = await provider.connection.getAccountInfo(address);\n                if (accountInfo === null) {\n                    throw new Error(`Account does not exist ${address.toString()}`);\n                }\n                // Assert the account discriminator is correct.\n                const discriminator = await accountDiscriminator(idlAccount.name);\n                if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n                    throw new Error(\"Invalid account discriminator\");\n                }\n                return coder.accounts.decode(idlAccount.name, accountInfo.data);\n            };\n            // Returns the size of the account.\n            // @ts-ignore\n            accountsNamespace[\"size\"] =\n                ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount);\n            // Returns an instruction for creating this account.\n            // @ts-ignore\n            accountsNamespace[\"createInstruction\"] = async (account, sizeOverride) => {\n                // @ts-ignore\n                const size = accountsNamespace[\"size\"];\n                return SystemProgram.createAccount({\n                    fromPubkey: provider.wallet.publicKey,\n                    newAccountPubkey: account.publicKey,\n                    space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n                    lamports: await provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n                    programId,\n                });\n            };\n            // Subscribes to all changes to this account.\n            // @ts-ignore\n            accountsNamespace[\"subscribe\"] = (address, commitment) => {\n                if (subscriptions.get(address.toString())) {\n                    return subscriptions.get(address.toString()).ee;\n                }\n                const ee = new EventEmitter();\n                const listener = provider.connection.onAccountChange(address, (acc) => {\n                    const account = coder.accounts.decode(idlAccount.name, acc.data);\n                    ee.emit(\"change\", account);\n                }, commitment);\n                subscriptions.set(address.toString(), {\n                    ee,\n                    listener,\n                });\n                return ee;\n            };\n            // Unsubscribes to account changes.\n            // @ts-ignore\n            accountsNamespace[\"unsubscribe\"] = (address) => {\n                let sub = subscriptions.get(address.toString());\n                if (!sub) {\n                    console.warn(\"Address is not subscribed\");\n                    return;\n                }\n                if (subscriptions) {\n                    provider.connection\n                        .removeAccountChangeListener(sub.listener)\n                        .then(() => {\n                        subscriptions.delete(address.toString());\n                    })\n                        .catch(console.error);\n                }\n            };\n            // Returns all instances of this account type for the program.\n            // @ts-ignore\n            accountsNamespace[\"all\"] = async (filter) => {\n                let bytes = await accountDiscriminator(idlAccount.name);\n                if (filter !== undefined) {\n                    bytes = Buffer.concat([bytes, filter]);\n                }\n                // @ts-ignore\n                let resp = await provider.connection._rpcRequest(\"getProgramAccounts\", [\n                    programId.toBase58(),\n                    {\n                        commitment: provider.connection.commitment,\n                        filters: [\n                            {\n                                memcmp: {\n                                    offset: 0,\n                                    bytes: bs58.encode(bytes),\n                                },\n                            },\n                        ],\n                        encoding: 'base64',\n                    },\n                ]);\n                if (resp.error) {\n                    console.error(resp);\n                    throw new Error(\"Failed to get accounts\");\n                }\n                return (resp.result\n                    .map(({ pubkey, account: { data } }) => {\n                    data = bs58.decode(bs58.encode(Uint8Array.from(atob(data[0]), c => c.charCodeAt(0))));\n                    return {\n                        publicKey: new PublicKey(pubkey),\n                        account: coder.accounts.decode(idlAccount.name, data),\n                    };\n                }));\n            };\n            // Function returning the associated address. Args are keys to associate.\n            // Order matters.\n            accountsNamespace[\"associatedAddress\"] = async (...args) => {\n                let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n                args.forEach((arg) => {\n                    seeds.push(arg.toBuffer());\n                });\n                const [assoc] = await PublicKey.findProgramAddress(seeds, programId);\n                return assoc;\n            };\n            // Function returning the associated account. Args are keys to associate.\n            // Order matters.\n            accountsNamespace[\"associated\"] = async (...args) => {\n                const addr = await accountsNamespace[\"associatedAddress\"](...args);\n                return await accountsNamespace(addr);\n            };\n            accountFns[name] = accountsNamespace;\n        });\n        return accountFns;\n    }\n}\nfunction translateError(idlErrors, err) {\n    // TODO: don't rely on the error string. web3.js should preserve the error\n    //       code information instead of giving us an untyped string.\n    let components = err.toString().split(\"custom program error: \");\n    if (components.length === 2) {\n        try {\n            const errorCode = parseInt(components[1]);\n            let errorMsg = idlErrors.get(errorCode);\n            if (errorMsg === undefined) {\n                // Unexpected error code so just throw the untranslated error.\n                return null;\n            }\n            return new ProgramError(errorCode, errorMsg);\n        }\n        catch (parseErr) {\n            // Unable to parse the error. Just return the untranslated error.\n            return null;\n        }\n    }\n}\nfunction parseIdlErrors(idl) {\n    const errors = new Map();\n    if (idl.errors) {\n        idl.errors.forEach((e) => {\n            var _a;\n            let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n            errors.set(e.code, msg);\n        });\n    }\n    return errors;\n}\nfunction splitArgsAndCtx(idlIx, args) {\n    let options = {};\n    const inputLen = idlIx.args ? idlIx.args.length : 0;\n    if (args.length > inputLen) {\n        if (args.length !== inputLen + 1) {\n            throw new Error(\"provided too many arguments ${args}\");\n        }\n        options = args.pop();\n    }\n    return [args, options];\n}\n// Allow either IdLInstruction or IdlStateMethod since the types share fields.\nfunction toInstruction(idlIx, ...args) {\n    if (idlIx.args.length != args.length) {\n        throw new Error(\"Invalid argument length\");\n    }\n    const ix = {};\n    let idx = 0;\n    idlIx.args.forEach((ixArg) => {\n        ix[ixArg.name] = args[idx];\n        idx += 1;\n    });\n    return ix;\n}\n// Throws error if any account required for the `ix` is not given.\nfunction validateAccounts(ixAccounts, accounts) {\n    ixAccounts.forEach((acc) => {\n        // @ts-ignore\n        if (acc.accounts !== undefined) {\n            // @ts-ignore\n            validateAccounts(acc.accounts, accounts[acc.name]);\n        }\n        else {\n            if (accounts[acc.name] === undefined) {\n                throw new Error(`Invalid arguments: ${acc.name} not provided.`);\n            }\n        }\n    });\n}\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix, ...args) {\n    // todo\n}\n// Calculates the deterministic address of the program's \"state\" account.\nasync function programStateAddress(programId) {\n    let [registrySigner, _nonce] = await PublicKey.findProgramAddress([], programId);\n    return PublicKey.createWithSeed(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nasync function stateInstructionKeys(programId, provider, m, accounts) {\n    if (m.name === \"new\") {\n        // Ctor `new` method.\n        const [programSigner, _nonce] = await PublicKey.findProgramAddress([], programId);\n        return [\n            {\n                pubkey: provider.wallet.publicKey,\n                isWritable: false,\n                isSigner: true,\n            },\n            {\n                pubkey: await programStateAddress(programId),\n                isWritable: true,\n                isSigner: false,\n            },\n            { pubkey: programSigner, isWritable: false, isSigner: false },\n            {\n                pubkey: SystemProgram.programId,\n                isWritable: false,\n                isSigner: false,\n            },\n            { pubkey: programId, isWritable: false, isSigner: false },\n            {\n                pubkey: SYSVAR_RENT_PUBKEY,\n                isWritable: false,\n                isSigner: false,\n            },\n        ];\n    }\n    else {\n        validateAccounts(m.accounts, accounts);\n        return [\n            {\n                pubkey: await programStateAddress(programId),\n                isWritable: true,\n                isSigner: false,\n            },\n        ];\n    }\n}\n//# sourceMappingURL=rpc.js.map"]},"metadata":{},"sourceType":"module"}