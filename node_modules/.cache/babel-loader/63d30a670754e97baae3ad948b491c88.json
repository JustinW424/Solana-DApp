{"ast":null,"code":"import { inflate } from \"pako\";\nimport { RpcFactory } from \"./rpc\";\nimport { idlAddress, decodeIdlAccount } from \"./idl\";\nimport Coder, { eventDiscriminator } from \"./coder\";\nimport { getProvider } from \"./\";\nimport * as base64 from \"base64-js\";\nimport * as assert from \"assert\";\n/**\n * Program is the IDL deserialized representation of a Solana program.\n */\n\nexport class Program {\n  constructor(idl, programId, provider) {\n    this.idl = idl;\n    this.programId = programId;\n    this.provider = provider !== null && provider !== void 0 ? provider : getProvider(); // Build the serializer.\n\n    const coder = new Coder(idl); // Build the dynamic RPC functions.\n\n    const [rpcs, ixs, txs, accounts, state] = RpcFactory.build(idl, coder, programId, this.provider);\n    this.rpc = rpcs;\n    this.instruction = ixs;\n    this.transaction = txs;\n    this.account = accounts;\n    this.coder = coder;\n    this.state = state;\n  }\n  /**\n   * Generates a Program client by fetching the IDL from chain.\n   */\n\n\n  static async at(programId, provider) {\n    const idl = await Program.fetchIdl(programId, provider);\n    return new Program(idl, programId, provider);\n  }\n  /**\n   * Fetches an idl from the blockchain.\n   */\n\n\n  static async fetchIdl(programId, provider) {\n    provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    const address = await idlAddress(programId);\n    const accountInfo = await provider.connection.getAccountInfo(address); // Chop off account discriminator.\n\n    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n    const inflatedIdl = inflate(idlAccount.data);\n    return JSON.parse(decodeUtf8(inflatedIdl));\n  }\n  /**\n   * Invokes the given callback everytime the given event is emitted.\n   */\n\n\n  addEventListener(eventName, callback) {\n    // Values shared across log handlers.\n    const thisProgramStr = this.programId.toString();\n    const discriminator = eventDiscriminator(eventName);\n    const logStartIndex = \"Program log: \".length; // Handles logs when the current program being executing is *not* this.\n\n    const handleSystemLog = log => {\n      // System component.\n      const logStart = log.split(\":\")[0]; // Recursive call.\n\n      if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n        return [this.programId.toString(), false];\n      } // Cpi call.\n      else if (logStart.includes(\"invoke\")) {\n        return [\"cpi\", false]; // Any string will do.\n      } else {\n        // Did the program finish executing?\n        if (logStart.match(/^Program (.*) consumed .*$/g) !== null) {\n          return [null, true];\n        }\n\n        return [null, false];\n      }\n    }; // Handles logs from *this* program.\n\n\n    const handleProgramLog = log => {\n      // This is a `msg!` log.\n      if (log.startsWith(\"Program log:\")) {\n        const logStr = log.slice(logStartIndex);\n        const logArr = Buffer.from(base64.toByteArray(logStr));\n        const disc = logArr.slice(0, 8); // Only deserialize if the discriminator implies a proper event.\n\n        let event = null;\n\n        if (disc.equals(discriminator)) {\n          event = this.coder.events.decode(eventName, logArr.slice(8));\n        }\n\n        return [event, null, false];\n      } // System log.\n      else {\n        return [null, ...handleSystemLog(log)];\n      }\n    }; // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n\n\n    const handleLog = (execution, log) => {\n      // Executing program is this program.\n      if (execution.program() === thisProgramStr) {\n        return handleProgramLog(log);\n      } // Executing program is not this program.\n      else {\n        return [null, ...handleSystemLog(log)];\n      }\n    }; // Each log given, represents an array of messages emitted by\n    // a single transaction, which can execute many different programs across\n    // CPI boundaries. However, the subscription is only interested in the\n    // events emitted by *this* program. In achieving this, we keep track of the\n    // program execution context by parsing each log and looking for a CPI\n    // `invoke` call. If one exists, we know a new program is executing. So we\n    // push the programId onto a stack and switch the program context. This\n    // allows us to track, for a given log, which program was executing during\n    // its emission, thereby allowing us to know if a given log event was\n    // emitted by *this* program. If it was, then we parse the raw string and\n    // emit the event if the string matches the event being subscribed to.\n    //\n    // @ts-ignore\n\n\n    return this.provider.connection.onLogs(this.programId, (logs, ctx) => {\n      if (logs.err) {\n        console.error(logs);\n        return;\n      }\n\n      const logScanner = new LogScanner(logs.logs);\n      const execution = new ExecutionContext(logScanner.next());\n      let log = logScanner.next();\n\n      while (log !== null) {\n        let [event, newProgram, didPop] = handleLog(execution, log);\n\n        if (event) {\n          callback(event, ctx.slot);\n        }\n\n        if (newProgram) {\n          execution.push(newProgram);\n        }\n\n        if (didPop) {\n          execution.pop();\n        }\n\n        log = logScanner.next();\n      }\n    });\n  }\n\n  async removeEventListener(listener) {\n    // @ts-ignore\n    return this.provider.connection.removeOnLogsListener(listener);\n  }\n\n} // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\n\nclass ExecutionContext {\n  constructor(log) {\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    const program = /^Program (.*) invoke.*$/g.exec(log)[1];\n    this.stack = [program];\n  }\n\n  program() {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n\n  push(newProgram) {\n    this.stack.push(newProgram);\n  }\n\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n\n}\n\nclass LogScanner {\n  constructor(logs) {\n    this.logs = logs;\n  }\n\n  next() {\n    if (this.logs.length === 0) {\n      return null;\n    }\n\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n\n}\n\nfunction decodeUtf8(array) {\n  const decoder = typeof TextDecoder === \"undefined\" ? new (require(\"util\").TextDecoder)(\"utf-8\") // Node.\n  : new TextDecoder(\"utf-8\"); // Browser.\n\n  return decoder.decode(array);\n}","map":{"version":3,"sources":["../../src/program.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { inflate } from \"pako\";\nimport { RpcFactory } from \"./rpc\";\nimport { idlAddress, decodeIdlAccount } from \"./idl\";\nimport Coder, { eventDiscriminator } from \"./coder\";\nimport { getProvider } from \"./\";\nimport * as base64 from \"base64-js\";\nimport * as assert from \"assert\";\n/**\n * Program is the IDL deserialized representation of a Solana program.\n */\nexport class Program {\n    constructor(idl, programId, provider) {\n        this.idl = idl;\n        this.programId = programId;\n        this.provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        // Build the serializer.\n        const coder = new Coder(idl);\n        // Build the dynamic RPC functions.\n        const [rpcs, ixs, txs, accounts, state] = RpcFactory.build(idl, coder, programId, this.provider);\n        this.rpc = rpcs;\n        this.instruction = ixs;\n        this.transaction = txs;\n        this.account = accounts;\n        this.coder = coder;\n        this.state = state;\n    }\n    /**\n     * Generates a Program client by fetching the IDL from chain.\n     */\n    static async at(programId, provider) {\n        const idl = await Program.fetchIdl(programId, provider);\n        return new Program(idl, programId, provider);\n    }\n    /**\n     * Fetches an idl from the blockchain.\n     */\n    static async fetchIdl(programId, provider) {\n        provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        const address = await idlAddress(programId);\n        const accountInfo = await provider.connection.getAccountInfo(address);\n        // Chop off account discriminator.\n        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n        const inflatedIdl = inflate(idlAccount.data);\n        return JSON.parse(decodeUtf8(inflatedIdl));\n    }\n    /**\n     * Invokes the given callback everytime the given event is emitted.\n     */\n    addEventListener(eventName, callback) {\n        // Values shared across log handlers.\n        const thisProgramStr = this.programId.toString();\n        const discriminator = eventDiscriminator(eventName);\n        const logStartIndex = \"Program log: \".length;\n        // Handles logs when the current program being executing is *not* this.\n        const handleSystemLog = (log) => {\n            // System component.\n            const logStart = log.split(\":\")[0];\n            // Recursive call.\n            if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n                return [this.programId.toString(), false];\n            }\n            // Cpi call.\n            else if (logStart.includes(\"invoke\")) {\n                return [\"cpi\", false]; // Any string will do.\n            }\n            else {\n                // Did the program finish executing?\n                if (logStart.match(/^Program (.*) consumed .*$/g) !== null) {\n                    return [null, true];\n                }\n                return [null, false];\n            }\n        };\n        // Handles logs from *this* program.\n        const handleProgramLog = (log) => {\n            // This is a `msg!` log.\n            if (log.startsWith(\"Program log:\")) {\n                const logStr = log.slice(logStartIndex);\n                const logArr = Buffer.from(base64.toByteArray(logStr));\n                const disc = logArr.slice(0, 8);\n                // Only deserialize if the discriminator implies a proper event.\n                let event = null;\n                if (disc.equals(discriminator)) {\n                    event = this.coder.events.decode(eventName, logArr.slice(8));\n                }\n                return [event, null, false];\n            }\n            // System log.\n            else {\n                return [null, ...handleSystemLog(log)];\n            }\n        };\n        // Main log handler. Returns a three element array of the event, the\n        // next program that was invoked for CPI, and a boolean indicating if\n        // a program has completed execution (and thus should be popped off the\n        // execution stack).\n        const handleLog = (execution, log) => {\n            // Executing program is this program.\n            if (execution.program() === thisProgramStr) {\n                return handleProgramLog(log);\n            }\n            // Executing program is not this program.\n            else {\n                return [null, ...handleSystemLog(log)];\n            }\n        };\n        // Each log given, represents an array of messages emitted by\n        // a single transaction, which can execute many different programs across\n        // CPI boundaries. However, the subscription is only interested in the\n        // events emitted by *this* program. In achieving this, we keep track of the\n        // program execution context by parsing each log and looking for a CPI\n        // `invoke` call. If one exists, we know a new program is executing. So we\n        // push the programId onto a stack and switch the program context. This\n        // allows us to track, for a given log, which program was executing during\n        // its emission, thereby allowing us to know if a given log event was\n        // emitted by *this* program. If it was, then we parse the raw string and\n        // emit the event if the string matches the event being subscribed to.\n        //\n        // @ts-ignore\n        return this.provider.connection.onLogs(this.programId, (logs, ctx) => {\n            if (logs.err) {\n                console.error(logs);\n                return;\n            }\n            const logScanner = new LogScanner(logs.logs);\n            const execution = new ExecutionContext(logScanner.next());\n            let log = logScanner.next();\n            while (log !== null) {\n                let [event, newProgram, didPop] = handleLog(execution, log);\n                if (event) {\n                    callback(event, ctx.slot);\n                }\n                if (newProgram) {\n                    execution.push(newProgram);\n                }\n                if (didPop) {\n                    execution.pop();\n                }\n                log = logScanner.next();\n            }\n        });\n    }\n    async removeEventListener(listener) {\n        // @ts-ignore\n        return this.provider.connection.removeOnLogsListener(listener);\n    }\n}\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n    constructor(log) {\n        // Assumes the first log in every transaction is an `invoke` log from the\n        // runtime.\n        const program = /^Program (.*) invoke.*$/g.exec(log)[1];\n        this.stack = [program];\n    }\n    program() {\n        assert.ok(this.stack.length > 0);\n        return this.stack[this.stack.length - 1];\n    }\n    push(newProgram) {\n        this.stack.push(newProgram);\n    }\n    pop() {\n        assert.ok(this.stack.length > 0);\n        this.stack.pop();\n    }\n}\nclass LogScanner {\n    constructor(logs) {\n        this.logs = logs;\n    }\n    next() {\n        if (this.logs.length === 0) {\n            return null;\n        }\n        let l = this.logs[0];\n        this.logs = this.logs.slice(1);\n        return l;\n    }\n}\nfunction decodeUtf8(array) {\n    const decoder = typeof TextDecoder === \"undefined\"\n        ? new (require(\"util\").TextDecoder)(\"utf-8\") // Node.\n        : new TextDecoder(\"utf-8\"); // Browser.\n    return decoder.decode(array);\n}\n//# sourceMappingURL=program.js.map"]},"metadata":{},"sourceType":"module"}