{"ast":null,"code":"import * as bs58 from \"bs58\";\nimport { sha256 } from \"crypto-hash\";\nimport assert from \"assert\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { idlAddress } from \"./idl\";\nexport const TOKEN_PROGRAM_ID = new PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\n\nasync function getMultipleAccounts(connection, publicKeys) {\n  const args = [publicKeys.map(k => k.toBase58()), {\n    commitment: \"recent\"\n  }]; // @ts-ignore\n\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n\n  if (res.error) {\n    throw new Error(\"failed to get info about accounts \" + publicKeys.map(k => k.toBase58()).join(\", \") + \": \" + res.error.message);\n  }\n\n  assert(typeof res.result !== \"undefined\");\n  const accounts = [];\n\n  for (const account of res.result.value) {\n    let value = null;\n\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n\n    if (res.result.value) {\n      const {\n        executable,\n        owner,\n        lamports,\n        data\n      } = account;\n      assert(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\")\n      };\n    }\n\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n\n    accounts.push(value);\n  }\n\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n\n    return {\n      publicKey: publicKeys[idx],\n      account\n    };\n  });\n}\n\nconst utils = {\n  bs58,\n  sha256,\n  getMultipleAccounts,\n  idlAddress\n};\nexport default utils;","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,IAAZ,MAAsB,MAAtB;AACA,SAAS,MAAT,QAAuB,aAAvB;AACA,OAAO,MAAP,MAAmB,QAAnB;AACA,SAAS,SAAT,QAAmD,iBAAnD;AACA,SAAS,UAAT,QAA2B,OAA3B;AAEA,OAAO,MAAM,gBAAgB,GAAG,IAAI,SAAJ,CAC9B,6CAD8B,CAAzB;;AAIP,eAAe,mBAAf,CACE,UADF,EAEE,UAFF,EAEyB;AAIvB,QAAM,IAAI,GAAG,CAAC,UAAU,CAAC,GAAX,CAAgB,CAAD,IAAO,CAAC,CAAC,QAAF,EAAtB,CAAD,EAAsC;AAAE,IAAA,UAAU,EAAE;AAAd,GAAtC,CAAb,CAJuB,CAKvB;;AACA,QAAM,GAAG,GAAG,MAAM,UAAU,CAAC,WAAX,CAAuB,qBAAvB,EAA8C,IAA9C,CAAlB;;AACA,MAAI,GAAG,CAAC,KAAR,EAAe;AACb,UAAM,IAAI,KAAJ,CACJ,uCACE,UAAU,CAAC,GAAX,CAAgB,CAAD,IAAO,CAAC,CAAC,QAAF,EAAtB,EAAoC,IAApC,CAAyC,IAAzC,CADF,GAEE,IAFF,GAGE,GAAG,CAAC,KAAJ,CAAU,OAJR,CAAN;AAMD;;AACD,EAAA,MAAM,CAAC,OAAO,GAAG,CAAC,MAAX,KAAsB,WAAvB,CAAN;AACA,QAAM,QAAQ,GAKT,EALL;;AAMA,OAAK,MAAM,OAAX,IAAsB,GAAG,CAAC,MAAJ,CAAW,KAAjC,EAAwC;AACtC,QAAI,KAAK,GAKE,IALX;;AAMA,QAAI,OAAO,KAAK,IAAhB,EAAsB;AACpB,MAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;AACA;AACD;;AACD,QAAI,GAAG,CAAC,MAAJ,CAAW,KAAf,EAAsB;AACpB,YAAM;AAAE,QAAA,UAAF;AAAc,QAAA,KAAd;AAAqB,QAAA,QAArB;AAA+B,QAAA;AAA/B,UAAwC,OAA9C;AACA,MAAA,MAAM,CAAC,IAAI,CAAC,CAAD,CAAJ,KAAY,QAAb,CAAN;AACA,MAAA,KAAK,GAAG;AACN,QAAA,UADM;AAEN,QAAA,KAAK,EAAE,IAAI,SAAJ,CAAc,KAAd,CAFD;AAGN,QAAA,QAHM;AAIN,QAAA,IAAI,EAAE,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,CAAD,CAAhB,EAAqB,QAArB;AAJA,OAAR;AAMD;;AACD,QAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,YAAM,IAAI,KAAJ,CAAU,kBAAV,CAAN;AACD;;AACD,IAAA,QAAQ,CAAC,IAAT,CAAc,KAAd;AACD;;AACD,SAAO,QAAQ,CAAC,GAAT,CAAa,CAAC,OAAD,EAAU,GAAV,KAAiB;AACnC,QAAI,OAAO,KAAK,IAAhB,EAAsB;AACpB,aAAO,IAAP;AACD;;AACD,WAAO;AACL,MAAA,SAAS,EAAE,UAAU,CAAC,GAAD,CADhB;AAEL,MAAA;AAFK,KAAP;AAID,GARM,CAAP;AASD;;AAED,MAAM,KAAK,GAAG;AACZ,EAAA,IADY;AAEZ,EAAA,MAFY;AAGZ,EAAA,mBAHY;AAIZ,EAAA;AAJY,CAAd;AAOA,eAAe,KAAf","sourceRoot":"","sourcesContent":["import * as bs58 from \"bs58\";\nimport { sha256 } from \"crypto-hash\";\nimport assert from \"assert\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { idlAddress } from \"./idl\";\nexport const TOKEN_PROGRAM_ID = new PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\nasync function getMultipleAccounts(connection, publicKeys) {\n    const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n    // @ts-ignore\n    const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n    if (res.error) {\n        throw new Error(\"failed to get info about accounts \" +\n            publicKeys.map((k) => k.toBase58()).join(\", \") +\n            \": \" +\n            res.error.message);\n    }\n    assert(typeof res.result !== \"undefined\");\n    const accounts = [];\n    for (const account of res.result.value) {\n        let value = null;\n        if (account === null) {\n            accounts.push(null);\n            continue;\n        }\n        if (res.result.value) {\n            const { executable, owner, lamports, data } = account;\n            assert(data[1] === \"base64\");\n            value = {\n                executable,\n                owner: new PublicKey(owner),\n                lamports,\n                data: Buffer.from(data[0], \"base64\"),\n            };\n        }\n        if (value === null) {\n            throw new Error(\"Invalid response\");\n        }\n        accounts.push(value);\n    }\n    return accounts.map((account, idx) => {\n        if (account === null) {\n            return null;\n        }\n        return {\n            publicKey: publicKeys[idx],\n            account,\n        };\n    });\n}\nconst utils = {\n    bs58,\n    sha256,\n    getMultipleAccounts,\n    idlAddress,\n};\nexport default utils;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}