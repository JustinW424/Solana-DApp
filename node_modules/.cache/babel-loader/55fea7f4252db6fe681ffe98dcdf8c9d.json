{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useEffect, useCallback } from 'react';\nimport * as BufferLayout from 'buffer-layout';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSnackbar } from 'notistack';\nimport { PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { parseMintAccount, parseTokenAccount } from '@project-serum/common';\nimport * as anchor from '@project-serum/anchor';\nimport { ActionType } from '../../store/actions';\nimport { useWallet } from './WalletProvider';\nimport { memberSeed } from '../../utils/registry'; // BootstrapProvider performs data fetching on application startup.\n\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function BootstrapProvider(props) {\n  _s();\n\n  const {\n    bootstrapTrigger,\n    shutdownTrigger,\n    network,\n    registrar\n  } = useSelector(state => {\n    return {\n      bootstrapTrigger: state.common.bootstrapTrigger,\n      shutdownTrigger: state.common.shutdownTrigger,\n      network: state.common.network,\n      registrar: state.registry.registrar\n    };\n  });\n  const dispatch = useDispatch();\n  const {\n    wallet,\n    lockupClient,\n    registryClient\n  } = useWallet();\n  const {\n    enqueueSnackbar\n  } = useSnackbar(); // Entry point for bootstrapping all the data for the app.\n\n  const bootstrap = useCallback(async () => {\n    enqueueSnackbar(`Connecting to ${network.label}`, {\n      variant: 'info',\n      autoHideDuration: 2500\n    });\n    dispatch({\n      type: ActionType.CommonAppWillBootstrap,\n      item: {}\n    });\n    let {\n      registrars,\n      members\n    } = await refreshAccounts({\n      dispatch,\n      lockupClient,\n      registryClient,\n      network,\n      wallet\n    }); // Temporary account store for the initial registrar switch.\n\n    const accountStore = Object.fromEntries(new Map(registrars.map(r => [r.publicKey.toString(), r.account])));\n    members.forEach(m => {\n      accountStore[m.publicKey.toString()] = m.account;\n    });\n    await registrarSwitch(registryClient, accountStore, dispatch, registrar, undefined);\n    dispatch({\n      type: ActionType.CommonAppDidBootstrap,\n      item: {}\n    });\n    enqueueSnackbar(`Connection established`, {\n      variant: 'success',\n      autoHideDuration: 2500\n    });\n  }, [dispatch, enqueueSnackbar, registryClient, registrar, lockupClient, network, wallet]);\n  const shutdown = useCallback(async () => {\n    wallet.disconnect();\n    dispatch({\n      type: ActionType.CommonDidShutdown,\n      item: {}\n    });\n  }, [dispatch, wallet]);\n  useEffect(() => {\n    if (bootstrapTrigger) {\n      bootstrap().catch(err => {\n        console.error(err);\n        enqueueSnackbar(`Error bootstrapping application: ${err.toString()}`, {\n          variant: 'error'\n        });\n      });\n    }\n\n    if (shutdownTrigger) {\n      shutdown().catch(err => {\n        console.error(err);\n        enqueueSnackbar(`Error shutting down application: ${err.toString()}`, {\n          variant: 'error'\n        });\n      });\n    }\n  }, [bootstrapTrigger, bootstrap, shutdownTrigger, shutdown, enqueueSnackbar]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: props.children\n  }, void 0, false);\n} // Fetches and populates the redux store with all accounts needed for the app to start.\n\n_s(BootstrapProvider, \"mYfcbvymDX8OVyaBFJRlGtHp+Dw=\", false, function () {\n  return [useSelector, useDispatch, useWallet, useSnackbar];\n});\n\n_c = BootstrapProvider;\nexport async function refreshAccounts(_ref) {\n  let {\n    dispatch,\n    lockupClient,\n    registryClient,\n    network,\n    wallet\n  } = _ref;\n\n  // Fetch all staking instances.\n  const fetchRegistrars = async () => {\n    const registrarAddresses = Object.values(network.registrars); // All registrars.\n\n    const registrars = (await anchor.utils.getMultipleAccounts(registryClient.provider.connection, registrarAddresses)).map(raw => {\n      const account = registryClient.coder.accounts.decode('Registrar', raw.account.data);\n      return {\n        publicKey: raw.publicKey,\n        account\n      };\n    }); // Mint for each registrar.\n\n    const mints = (await anchor.utils.getMultipleAccounts(registryClient.provider.connection, registrars.map(r => r.account.mint))).map(raw => {\n      const account = parseMintAccount(raw.account.data);\n      return {\n        publicKey: raw.publicKey,\n        account\n      };\n    }); // Reward queues for each registrar.\n\n    const rewardQs = (await anchor.utils.getMultipleAccounts(registryClient.provider.connection, registrars.map(r => r.account.rewardEventQ))).map(raw => {\n      const account = registryClient.coder.accounts.decode('RewardQueue', raw.account.data);\n      return {\n        publicKey: raw.publicKey,\n        account\n      };\n    }); // Add all the accounts to the store.\n\n    registrars.concat(mints).concat(rewardQs).forEach(r => {\n      dispatch({\n        type: ActionType.AccountAdd,\n        item: {\n          account: r\n        }\n      });\n    });\n    return registrars;\n  }; // Fetch the stake accounts for each staking instance (for the connected wallet).\n\n\n  const fetchMembers = async registrars => {\n    const members = await Promise.all(registrars.map(r => r.publicKey).map(r => memberSeed(r).then(seed => PublicKey.createWithSeed(wallet.publicKey, seed, registryClient.programId)).then(member => {\n      return {\n        memberPublicKey: member,\n        registrar: r\n      };\n    })));\n    const memberAddresses = members.map(m => m.memberPublicKey);\n    const memberAccounts = (await anchor.utils.getMultipleAccounts(registryClient.provider.connection, memberAddresses)).filter(raw => raw !== null).map(raw => {\n      const account = registryClient.coder.accounts.decode('Member', raw.account.data);\n      return {\n        publicKey: raw.publicKey,\n        account\n      };\n    }); // Get all accounts for all of our member accounts.\n    //\n    // Note: As the number of registrars grows, we'll probably want to move\n    //       this fetch to be an on demand query, rather than on application\n    //       bootstrap.\n\n    await Promise.all(memberAccounts.map(memberAccount => {\n      return fetchAndDispatchMemberAccounts(memberAccount, dispatch, registryClient.provider.connection);\n    })); // Add all the member accounts to the store. Must be done *after* the\n    // active member's vaults.\n\n    memberAccounts.forEach(m => {\n      dispatch({\n        type: ActionType.AccountAdd,\n        item: {\n          account: m\n        }\n      });\n    });\n    return memberAccounts;\n  }; // All mints for each staking instance (pool token and the token being staked).\n\n\n  const fetchMints = async registrars => {\n    const mintAddresses = registrars.map(r => r.account.mint).concat(registrars.map(r => r.account.poolMint));\n    const mints = (await anchor.utils.getMultipleAccounts(registryClient.provider.connection, mintAddresses)).map(raw => {\n      const account = parseMintAccount(raw.account.data);\n      return {\n        publicKey: raw.publicKey,\n        account\n      };\n    });\n    mints.forEach(m => {\n      dispatch({\n        type: ActionType.AccountAdd,\n        item: {\n          account: m\n        }\n      });\n    });\n  }; // All token accounts owned by the current user.\n\n\n  const fetchOwnedTokenAccounts = async () => {\n    const ownedTokenAccounts = await getOwnedTokenAccounts(lockupClient.provider.connection, wallet.publicKey);\n    dispatch({\n      type: ActionType.CommonOwnedTokenAccountsSet,\n      item: {\n        ownedTokenAccounts\n      }\n    });\n  }; // All vesting accounts owned by the current user.\n\n\n  const fetchVestingAccounts = async () => {\n    const vestingAccounts = await lockupClient.account.vesting.all(wallet.publicKey.toBuffer());\n    vestingAccounts.forEach(account => {\n      dispatch({\n        type: ActionType.AccountAdd,\n        item: {\n          account\n        }\n      });\n    });\n    dispatch({\n      type: ActionType.LockupSetVestings,\n      item: {\n        vestingAccounts: vestingAccounts.map(v => v.publicKey)\n      }\n    });\n  };\n\n  const registrars = await fetchRegistrars();\n  const members = await fetchMembers(registrars);\n  await fetchMints(registrars);\n  await fetchOwnedTokenAccounts();\n  await fetchVestingAccounts();\n  return {\n    registrars,\n    members\n  };\n}\nexport async function registrarSwitch(registryClient, accounts, dispatch, newRegistrar, oldRegistrar) {\n  const oldMember = await (async () => {\n    if (oldRegistrar === undefined) {\n      return undefined;\n    }\n\n    const oldMember = await PublicKey.createWithSeed(registryClient.provider.wallet.publicKey, await memberSeed(oldRegistrar), registryClient.programId);\n    const oldMemberAccount = accounts[oldMember.toString()];\n    return oldMemberAccount !== undefined ? {\n      publicKey: oldMember,\n      account: oldMemberAccount\n    } : undefined;\n  })();\n  const newMember = await (async () => {\n    const newMember = await PublicKey.createWithSeed(registryClient.provider.wallet.publicKey, await memberSeed(newRegistrar), registryClient.programId);\n    const newMemberAccount = accounts[newMember.toString()];\n    return newMemberAccount ? {\n      publicKey: newMember,\n      account: newMemberAccount\n    } : undefined;\n  })();\n  await subscribeRegistrar(registryClient, accounts, dispatch, newRegistrar, oldRegistrar);\n\n  if (newMember) {\n    unsubscribeMember(registryClient, oldMember);\n    subscribeMember(newMember, registryClient, dispatch);\n  } // Perform the UI update.\n\n\n  dispatch({\n    type: ActionType.RegistrySetRegistrar,\n    item: {\n      registrar: newRegistrar,\n      member: newMember ? newMember.publicKey : undefined\n    }\n  });\n}\nexport async function subscribeRegistrar(registryClient, accounts, dispatch, newRegistrar, oldRegistrar) {\n  if (oldRegistrar) {\n    const oldRegistrarAccount = accounts[oldRegistrar.toString()];\n    registryClient.account.rewardQueue.unsubscribe(oldRegistrarAccount.rewardEventQ); // TODO: unsubscribe from the staking pool subscription.\n  }\n\n  const newRegistrarAccount = accounts[newRegistrar.toString()]; // Reward event queue sub.\n\n  const conn = registryClient.account.rewardQueue.subscribe(newRegistrarAccount.rewardEventQ);\n  conn.on('change', account => {\n    dispatch({\n      type: ActionType.AccountUpdate,\n      item: {\n        account: {\n          publicKey: newRegistrarAccount.rewardEventQ,\n          account\n        }\n      }\n    });\n  }); // Staking pool token sub.\n  // TODO: track these connections somewhere more organized.\n\n  registryClient.provider.connection.onAccountChange(newRegistrarAccount.poolMint, acc => {\n    const poolMint = parseMintAccount(acc.data);\n    dispatch({\n      type: ActionType.AccountUpdate,\n      item: {\n        account: {\n          publicKey: newRegistrarAccount.poolMint,\n          account: poolMint\n        }\n      }\n    });\n  }, 'recent');\n}\nexport function subscribeMember(newMember, registryClient, dispatch) {\n  // Subscribe to all member account updates.\n  registryClient.account.member.subscribe(newMember.publicKey).on('change', account => {\n    dispatch({\n      type: ActionType.AccountUpdate,\n      item: {\n        account: {\n          publicKey: newMember.publicKey,\n          account\n        }\n      }\n    });\n  }); // Subscription function, updating the redux store on every change\n  // to a token account.\n  //\n  // TODO: should track these subscriptions for unsubscribing on demand.\n\n  const createVaultSubscription = address => {\n    registryClient.provider.connection.onAccountChange(address, acc => {\n      const tokenAccount = parseTokenAccount(acc.data);\n      dispatch({\n        type: ActionType.AccountUpdate,\n        item: {\n          account: {\n            publicKey: address,\n            account: tokenAccount\n          }\n        }\n      });\n    }, 'recent');\n  }; // Subscribe to all the member's token vaults.\n\n\n  createVaultSubscription(newMember.account.balances.vault);\n  createVaultSubscription(newMember.account.balances.vaultStake);\n  createVaultSubscription(newMember.account.balances.vaultPw);\n  createVaultSubscription(newMember.account.balances.spt);\n  createVaultSubscription(newMember.account.balancesLocked.vault);\n  createVaultSubscription(newMember.account.balancesLocked.vaultStake);\n  createVaultSubscription(newMember.account.balancesLocked.vaultPw);\n  createVaultSubscription(newMember.account.balancesLocked.spt);\n}\n\nfunction unsubscribeMember(registryClient, newMember) {// todo\n} // Fetches all accounts for a member account and populates the store with them.\n\n\nexport async function fetchAndDispatchMemberAccounts(memberAccount, dispatch, connection) {\n  let accounts = (await anchor.utils.getMultipleAccounts(connection, [memberAccount.account.balances.vault, memberAccount.account.balances.vaultStake, memberAccount.account.balances.vaultPw, memberAccount.account.balances.spt, memberAccount.account.balancesLocked.vault, memberAccount.account.balancesLocked.vaultStake, memberAccount.account.balancesLocked.vaultPw, memberAccount.account.balancesLocked.spt])).filter(raw => raw !== null).map(raw => {\n    return {\n      publicKey: raw.publicKey,\n      account: parseTokenAccount(raw.account.data)\n    };\n  });\n  accounts.forEach(account => {\n    dispatch({\n      type: ActionType.AccountAdd,\n      item: {\n        account\n      }\n    });\n  });\n}\nexport async function getOwnedTokenAccounts(connection, publicKey) {\n  let filters = getOwnedAccountsFilters(publicKey);\n  let resp = await connection.getProgramAccounts(TOKEN_PROGRAM_ID, {\n    filters\n  });\n  const result = resp.map(_ref2 => {\n    let {\n      pubkey,\n      account: {\n        data\n      }\n    } = _ref2;\n    return {\n      publicKey: new PublicKey(pubkey),\n      account: parseTokenAccountData(data)\n    };\n  });\n  return result;\n}\nexport const ACCOUNT_LAYOUT = BufferLayout.struct([BufferLayout.blob(32, 'mint'), BufferLayout.blob(32, 'owner'), BufferLayout.nu64('amount'), BufferLayout.blob(93)]);\nexport function getOwnedAccountsFilters(publicKey) {\n  return [{\n    memcmp: {\n      // @ts-ignore\n      offset: ACCOUNT_LAYOUT.offsetOf('owner'),\n      bytes: publicKey.toBase58()\n    }\n  }, {\n    dataSize: ACCOUNT_LAYOUT.span\n  }];\n}\nexport function parseTokenAccountData(data) {\n  // @ts-ignore\n  let {\n    mint,\n    owner,\n    amount\n  } = ACCOUNT_LAYOUT.decode(data);\n  return {\n    mint: new PublicKey(mint),\n    owner: new PublicKey(owner),\n    amount\n  };\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"BootstrapProvider\");","map":{"version":3,"sources":["F:/jobs/stake_in_solana/source/src/components/common/BootstrapProvider.tsx"],"names":["React","useEffect","useCallback","BufferLayout","useDispatch","useSelector","useSnackbar","PublicKey","TOKEN_PROGRAM_ID","parseMintAccount","parseTokenAccount","anchor","ActionType","useWallet","memberSeed","BootstrapProvider","props","bootstrapTrigger","shutdownTrigger","network","registrar","state","common","registry","dispatch","wallet","lockupClient","registryClient","enqueueSnackbar","bootstrap","label","variant","autoHideDuration","type","CommonAppWillBootstrap","item","registrars","members","refreshAccounts","accountStore","Object","fromEntries","Map","map","r","publicKey","toString","account","forEach","m","registrarSwitch","undefined","CommonAppDidBootstrap","shutdown","disconnect","CommonDidShutdown","catch","err","console","error","children","fetchRegistrars","registrarAddresses","values","utils","getMultipleAccounts","provider","connection","raw","coder","accounts","decode","data","mints","mint","rewardQs","rewardEventQ","concat","AccountAdd","fetchMembers","Promise","all","then","seed","createWithSeed","programId","member","memberPublicKey","memberAddresses","memberAccounts","filter","memberAccount","fetchAndDispatchMemberAccounts","fetchMints","mintAddresses","poolMint","fetchOwnedTokenAccounts","ownedTokenAccounts","getOwnedTokenAccounts","CommonOwnedTokenAccountsSet","fetchVestingAccounts","vestingAccounts","vesting","toBuffer","LockupSetVestings","v","newRegistrar","oldRegistrar","oldMember","oldMemberAccount","newMember","newMemberAccount","subscribeRegistrar","unsubscribeMember","subscribeMember","RegistrySetRegistrar","oldRegistrarAccount","rewardQueue","unsubscribe","newRegistrarAccount","conn","subscribe","on","AccountUpdate","onAccountChange","acc","createVaultSubscription","address","tokenAccount","balances","vault","vaultStake","vaultPw","spt","balancesLocked","filters","getOwnedAccountsFilters","resp","getProgramAccounts","result","pubkey","parseTokenAccountData","ACCOUNT_LAYOUT","struct","blob","nu64","memcmp","offset","offsetOf","bytes","toBase58","dataSize","span","owner","amount"],"mappings":"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","sourcesContent":["import React, {\n  PropsWithChildren,\n  ReactNode,\n  useEffect,\n  useCallback,\n} from 'react';\nimport * as BufferLayout from 'buffer-layout';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSnackbar } from 'notistack';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport {\n  parseMintAccount,\n  parseTokenAccount,\n} from '@project-serum/common';\nimport * as anchor from '@project-serum/anchor';\nimport { State as StoreState, ProgramAccount } from '../../store/reducer';\nimport { ActionType } from '../../store/actions';\nimport { useWallet } from './WalletProvider';\nimport { memberSeed } from '../../utils/registry';\n\n// BootstrapProvider performs data fetching on application startup.\nexport default function BootstrapProvider(props: PropsWithChildren<ReactNode>) {\n  const { bootstrapTrigger, shutdownTrigger, network, registrar } = useSelector(\n    (state: StoreState) => {\n      return {\n        bootstrapTrigger: state.common.bootstrapTrigger,\n        shutdownTrigger: state.common.shutdownTrigger,\n        network: state.common.network,\n        registrar: state.registry.registrar,\n      };\n    },\n  );\n  const dispatch = useDispatch();\n  const { wallet, lockupClient, registryClient } = useWallet();\n  const { enqueueSnackbar } = useSnackbar();\n\n  // Entry point for bootstrapping all the data for the app.\n  const bootstrap = useCallback(async () => {\n    enqueueSnackbar(`Connecting to ${network.label}`, {\n      variant: 'info',\n      autoHideDuration: 2500,\n    });\n\n    dispatch({\n      type: ActionType.CommonAppWillBootstrap,\n      item: {},\n    });\n\n    let { registrars, members } = await refreshAccounts({\n      dispatch,\n      lockupClient,\n      registryClient,\n      network,\n      wallet,\n    });\n\n    // Temporary account store for the initial registrar switch.\n    const accountStore = Object.fromEntries(\n      new Map(registrars.map(r => [r.publicKey.toString(), r.account])),\n    );\n    members.forEach(m => {\n      accountStore[m.publicKey.toString()] = m.account;\n    });\n\n    await registrarSwitch(\n      registryClient,\n      accountStore,\n      dispatch,\n      registrar,\n      undefined,\n    );\n\n    dispatch({\n      type: ActionType.CommonAppDidBootstrap,\n      item: {},\n    });\n\n    enqueueSnackbar(`Connection established`, {\n      variant: 'success',\n      autoHideDuration: 2500,\n    });\n  }, [\n    dispatch,\n    enqueueSnackbar,\n    registryClient,\n    registrar,\n    lockupClient,\n    network,\n    wallet,\n  ]);\n\n  const shutdown = useCallback(async () => {\n    wallet.disconnect();\n    dispatch({\n      type: ActionType.CommonDidShutdown,\n      item: {},\n    });\n  }, [dispatch, wallet]);\n\n  useEffect(() => {\n    if (bootstrapTrigger) {\n      bootstrap().catch(err => {\n        console.error(err);\n        enqueueSnackbar(`Error bootstrapping application: ${err.toString()}`, {\n          variant: 'error',\n        });\n      });\n    }\n    if (shutdownTrigger) {\n      shutdown().catch(err => {\n        console.error(err);\n        enqueueSnackbar(`Error shutting down application: ${err.toString()}`, {\n          variant: 'error',\n        });\n      });\n    }\n  }, [bootstrapTrigger, bootstrap, shutdownTrigger, shutdown, enqueueSnackbar]);\n\n  return <>{props.children}</>;\n}\n\n// Fetches and populates the redux store with all accounts needed for the app to start.\nexport async function refreshAccounts({\n  dispatch,\n  lockupClient,\n  registryClient,\n  network,\n  wallet,\n}: any) {\n  // Fetch all staking instances.\n  const fetchRegistrars = async (): Promise<ProgramAccount[]> => {\n    const registrarAddresses: PublicKey[] = Object.values(network.registrars);\n\n    // All registrars.\n    const registrars: ProgramAccount[] = (\n      await anchor.utils.getMultipleAccounts(\n        registryClient.provider.connection,\n        registrarAddresses,\n      )\n    ).map(raw => {\n      const account = registryClient.coder.accounts.decode(\n        'Registrar',\n        raw!.account.data,\n      );\n      return {\n        publicKey: raw!.publicKey,\n        account,\n      };\n    });\n\n    // Mint for each registrar.\n    const mints: ProgramAccount[] = (\n      await anchor.utils.getMultipleAccounts(\n        registryClient.provider.connection,\n        registrars.map(r => r.account.mint),\n      )\n    ).map(raw => {\n      const account = parseMintAccount(raw!.account.data);\n      return {\n        publicKey: raw!.publicKey,\n        account,\n      };\n    });\n\n    // Reward queues for each registrar.\n    const rewardQs = (\n      await anchor.utils.getMultipleAccounts(\n        registryClient.provider.connection,\n        registrars.map(r => r.account.rewardEventQ),\n      )\n    ).map(raw => {\n      const account = registryClient.coder.accounts.decode(\n        'RewardQueue',\n        raw!.account.data,\n      );\n      return {\n        publicKey: raw!.publicKey,\n        account,\n      };\n    });\n\n    // Add all the accounts to the store.\n    registrars\n      .concat(mints)\n      .concat(rewardQs)\n      .forEach(r => {\n        dispatch({\n          type: ActionType.AccountAdd,\n          item: {\n            account: r,\n          },\n        });\n      });\n    return registrars;\n  };\n\n  // Fetch the stake accounts for each staking instance (for the connected wallet).\n  const fetchMembers = async (\n    registrars: ProgramAccount[],\n  ): Promise<ProgramAccount[]> => {\n    const members = await Promise.all(\n      registrars\n        .map((r: ProgramAccount) => r.publicKey)\n        .map((r: PublicKey) =>\n          memberSeed(r)\n            .then(seed =>\n              PublicKey.createWithSeed(\n                wallet.publicKey,\n                seed,\n                registryClient.programId,\n              ),\n            )\n            .then(member => {\n              return {\n                memberPublicKey: member,\n                registrar: r,\n              };\n            }),\n        ),\n    );\n    const memberAddresses: PublicKey[] = members.map(m => m.memberPublicKey);\n    const memberAccounts: ProgramAccount[] = (\n      await anchor.utils.getMultipleAccounts(\n        registryClient.provider.connection,\n        memberAddresses,\n      )\n    )\n      .filter(raw => raw !== null)\n      .map((raw: any) => {\n        const account = registryClient.coder.accounts.decode(\n          'Member',\n          raw!.account.data,\n        );\n        return {\n          publicKey: raw!.publicKey,\n          account,\n        };\n      });\n\n    // Get all accounts for all of our member accounts.\n    //\n    // Note: As the number of registrars grows, we'll probably want to move\n    //       this fetch to be an on demand query, rather than on application\n    //       bootstrap.\n    await Promise.all(\n      memberAccounts.map(memberAccount => {\n        return fetchAndDispatchMemberAccounts(\n          memberAccount,\n          dispatch,\n          registryClient.provider.connection,\n        );\n      }),\n    );\n\n    // Add all the member accounts to the store. Must be done *after* the\n    // active member's vaults.\n    memberAccounts.forEach(m => {\n      dispatch({\n        type: ActionType.AccountAdd,\n        item: {\n          account: m,\n        },\n      });\n    });\n\n    return memberAccounts;\n  };\n\n  // All mints for each staking instance (pool token and the token being staked).\n  const fetchMints = async (registrars: ProgramAccount[]) => {\n    const mintAddresses = registrars\n      .map(r => r.account.mint)\n      .concat(registrars.map(r => r.account.poolMint));\n    const mints = (\n      await anchor.utils.getMultipleAccounts(\n        registryClient.provider.connection,\n        mintAddresses,\n      )\n    ).map(raw => {\n      const account = parseMintAccount(raw!.account.data);\n      return {\n        publicKey: raw!.publicKey,\n        account,\n      };\n    });\n    mints.forEach(m => {\n      dispatch({\n        type: ActionType.AccountAdd,\n        item: {\n          account: m,\n        },\n      });\n    });\n  };\n\n  // All token accounts owned by the current user.\n  const fetchOwnedTokenAccounts = async () => {\n    const ownedTokenAccounts = await getOwnedTokenAccounts(\n      lockupClient.provider.connection,\n      wallet.publicKey,\n    );\n    dispatch({\n      type: ActionType.CommonOwnedTokenAccountsSet,\n      item: {\n        ownedTokenAccounts,\n      },\n    });\n  };\n\n  // All vesting accounts owned by the current user.\n  const fetchVestingAccounts = async () => {\n    const vestingAccounts = await lockupClient.account.vesting.all(\n      wallet.publicKey.toBuffer(),\n    );\n    vestingAccounts.forEach((account: any) => {\n      dispatch({\n        type: ActionType.AccountAdd,\n        item: {\n          account,\n        },\n      });\n    });\n    dispatch({\n      type: ActionType.LockupSetVestings,\n      item: {\n        vestingAccounts: vestingAccounts.map(\n          (v: ProgramAccount) => v.publicKey,\n        ),\n      },\n    });\n  };\n\n  const registrars = await fetchRegistrars();\n  const members = await fetchMembers(registrars);\n  await fetchMints(registrars);\n  await fetchOwnedTokenAccounts();\n  await fetchVestingAccounts();\n\n  return { registrars, members };\n}\n\nexport async function registrarSwitch(\n  registryClient: any,\n  accounts: any,\n  dispatch: any,\n  newRegistrar: PublicKey,\n  oldRegistrar?: PublicKey,\n) {\n  const oldMember = await (async (): Promise<ProgramAccount | undefined> => {\n    if (oldRegistrar === undefined) {\n      return undefined;\n    }\n    const oldMember = await PublicKey.createWithSeed(\n      registryClient.provider.wallet.publicKey,\n      await memberSeed(oldRegistrar),\n      registryClient.programId,\n    );\n    const oldMemberAccount = accounts[oldMember.toString()];\n    return oldMemberAccount !== undefined\n      ? {\n          publicKey: oldMember,\n          account: oldMemberAccount,\n        }\n      : undefined;\n  })();\n\n  const newMember = await (async (): Promise<ProgramAccount | undefined> => {\n    const newMember = await PublicKey.createWithSeed(\n      registryClient.provider.wallet.publicKey,\n      await memberSeed(newRegistrar),\n      registryClient.programId,\n    );\n    const newMemberAccount = accounts[newMember.toString()];\n    return newMemberAccount\n      ? {\n          publicKey: newMember,\n          account: newMemberAccount,\n        }\n      : undefined;\n  })();\n\n  await subscribeRegistrar(\n    registryClient,\n    accounts,\n    dispatch,\n    newRegistrar,\n    oldRegistrar,\n  );\n  if (newMember) {\n    unsubscribeMember(registryClient, oldMember);\n    subscribeMember(newMember, registryClient, dispatch);\n  }\n\n  // Perform the UI update.\n  dispatch({\n    type: ActionType.RegistrySetRegistrar,\n    item: {\n      registrar: newRegistrar,\n      member: newMember ? newMember.publicKey : undefined,\n    },\n  });\n}\n\nexport async function subscribeRegistrar(\n  registryClient: any,\n  accounts: any,\n  dispatch: any,\n  newRegistrar: PublicKey,\n  oldRegistrar?: PublicKey,\n) {\n  if (oldRegistrar) {\n    const oldRegistrarAccount = accounts[oldRegistrar.toString()];\n    registryClient.account.rewardQueue.unsubscribe(\n      oldRegistrarAccount.rewardEventQ,\n    );\n    // TODO: unsubscribe from the staking pool subscription.\n  }\n\n  const newRegistrarAccount = accounts[newRegistrar.toString()];\n\n  // Reward event queue sub.\n  const conn = registryClient.account.rewardQueue.subscribe(\n    newRegistrarAccount.rewardEventQ,\n  );\n  conn.on('change', (account: any) => {\n    dispatch({\n      type: ActionType.AccountUpdate,\n      item: {\n        account: {\n          publicKey: newRegistrarAccount.rewardEventQ,\n          account,\n        },\n      },\n    });\n  });\n\n  // Staking pool token sub.\n  // TODO: track these connections somewhere more organized.\n  registryClient.provider.connection.onAccountChange(\n    newRegistrarAccount.poolMint,\n    (acc: any) => {\n      const poolMint = parseMintAccount(acc.data);\n      dispatch({\n        type: ActionType.AccountUpdate,\n        item: {\n          account: {\n            publicKey: newRegistrarAccount.poolMint,\n            account: poolMint,\n          },\n        },\n      });\n    },\n    'recent',\n  );\n}\n\nexport function subscribeMember(\n  newMember: ProgramAccount,\n  registryClient: any,\n  dispatch: any,\n) {\n  // Subscribe to all member account updates.\n  registryClient.account.member\n    .subscribe(newMember.publicKey)\n    .on('change', (account: any) => {\n      dispatch({\n        type: ActionType.AccountUpdate,\n        item: {\n          account: {\n            publicKey: newMember.publicKey,\n            account,\n          },\n        },\n      });\n    });\n\n  // Subscription function, updating the redux store on every change\n  // to a token account.\n  //\n  // TODO: should track these subscriptions for unsubscribing on demand.\n  const createVaultSubscription = (address: PublicKey) => {\n    registryClient.provider.connection.onAccountChange(\n      address,\n      (acc: any) => {\n        const tokenAccount = parseTokenAccount(acc.data);\n        dispatch({\n          type: ActionType.AccountUpdate,\n          item: {\n            account: {\n              publicKey: address,\n              account: tokenAccount,\n            },\n          },\n        });\n      },\n      'recent',\n    );\n  };\n\n  // Subscribe to all the member's token vaults.\n  createVaultSubscription(newMember.account.balances.vault);\n  createVaultSubscription(newMember.account.balances.vaultStake);\n  createVaultSubscription(newMember.account.balances.vaultPw);\n  createVaultSubscription(newMember.account.balances.spt);\n  createVaultSubscription(newMember.account.balancesLocked.vault);\n  createVaultSubscription(newMember.account.balancesLocked.vaultStake);\n  createVaultSubscription(newMember.account.balancesLocked.vaultPw);\n  createVaultSubscription(newMember.account.balancesLocked.spt);\n}\n\nfunction unsubscribeMember(registryClient: any, newMember?: ProgramAccount) {\n  // todo\n}\n\n// Fetches all accounts for a member account and populates the store with them.\nexport async function fetchAndDispatchMemberAccounts(\n  memberAccount: ProgramAccount,\n  dispatch: any,\n  connection: any,\n) {\n  let accounts = (\n    await anchor.utils.getMultipleAccounts(connection, [\n      memberAccount.account.balances.vault,\n      memberAccount.account.balances.vaultStake,\n      memberAccount.account.balances.vaultPw,\n      memberAccount.account.balances.spt,\n      memberAccount.account.balancesLocked.vault,\n      memberAccount.account.balancesLocked.vaultStake,\n      memberAccount.account.balancesLocked.vaultPw,\n      memberAccount.account.balancesLocked.spt,\n    ])\n  )\n    .filter(raw => raw !== null)\n    .map((raw: any) => {\n      return {\n        publicKey: raw.publicKey,\n        account: parseTokenAccount(raw.account.data),\n      };\n    });\n  accounts.forEach(account => {\n    dispatch({\n      type: ActionType.AccountAdd,\n      item: {\n        account,\n      },\n    });\n  });\n}\n\nexport async function getOwnedTokenAccounts(connection: Connection, publicKey: PublicKey) {\n  let filters = getOwnedAccountsFilters(publicKey);\n  let resp = await connection.getProgramAccounts(\n    TOKEN_PROGRAM_ID,\n    {\n      filters,\n    },\n  );\n  const result =  resp\n    .map(({ pubkey, account: { data } }) => {\n      return {\n        publicKey: new PublicKey(pubkey),\n        account: parseTokenAccountData(data),\n      };\n    });\n\n  return result;\n}\n\nexport const ACCOUNT_LAYOUT = BufferLayout.struct([\n  BufferLayout.blob(32, 'mint'),\n  BufferLayout.blob(32, 'owner'),\n  BufferLayout.nu64('amount'),\n  BufferLayout.blob(93),\n]);\n\n\nexport function getOwnedAccountsFilters(publicKey: PublicKey) {\n  return [\n    {\n      memcmp: {\n        // @ts-ignore\n        offset: ACCOUNT_LAYOUT.offsetOf('owner'),\n        bytes: publicKey.toBase58(),\n      },\n    },\n    {\n      dataSize: ACCOUNT_LAYOUT.span,\n    },\n  ];\n}\n\nexport function parseTokenAccountData(data: any) {\n  // @ts-ignore\n  let { mint, owner, amount } = ACCOUNT_LAYOUT.decode(data);\n  return {\n    mint: new PublicKey(mint),\n    owner: new PublicKey(owner),\n    amount,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}