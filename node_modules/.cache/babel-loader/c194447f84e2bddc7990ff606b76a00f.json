{"ast":null,"code":"import { Transaction, Account } from '@solana/web3.js';\nimport * as serumCmn from '@project-serum/common';\nimport * as anchor from '@project-serum/anchor';\nexport async function registrarSigner(programId, registrar) {\n  const [publicKey, nonce] = await anchor.web3.PublicKey.findProgramAddress([registrar.toBuffer()], programId);\n  return {\n    publicKey,\n    nonce\n  };\n}\nexport async function memberSigner(programId, registrar, member) {\n  const [publicKey, nonce] = await anchor.web3.PublicKey.findProgramAddress([registrar.toBuffer(), member.toBuffer()], programId);\n  return {\n    publicKey,\n    nonce\n  };\n}\nexport async function vendorSigner(programId, registrar, vendor) {\n  const [publicKey, nonce] = await anchor.web3.PublicKey.findProgramAddress([registrar.toBuffer(), vendor.toBuffer()], programId);\n  return {\n    publicKey,\n    nonce\n  };\n} // Returns the seed used to derive a member address. This is not necessary, but\n// a UX convenience. Each member address is a deterministic function of the\n// program, beneficiary, and this (constant) seed.\n\nexport async function memberSeed(registrar) {\n  console.log(registrar, \"temple 1\");\n  const seed = await anchor.utils.sha256(`${registrar.toString()}:Member`); // The max length of seeds allowed by Solana is 32.\n\n  return seed.slice(0, 32);\n} // Creates all the SPL otken vaults needed for constructing a `Member` account.\n\nexport async function createBalanceSandbox(provider, r, registrySigner) {\n  const spt = new Account();\n  const vault = new Account();\n  const vaultStake = new Account();\n  const vaultPw = new Account();\n  const lamports = await provider.connection.getMinimumBalanceForRentExemption(165);\n  const createSptIx = await serumCmn.createTokenAccountInstrs(provider, spt.publicKey, r.poolMint, registrySigner, lamports);\n  const createVaultIx = await serumCmn.createTokenAccountInstrs(provider, vault.publicKey, r.mint, registrySigner, lamports);\n  const createVaultStakeIx = await serumCmn.createTokenAccountInstrs(provider, vaultStake.publicKey, r.mint, registrySigner, lamports);\n  const createVaultPwIx = await serumCmn.createTokenAccountInstrs(provider, vaultPw.publicKey, r.mint, registrySigner, lamports);\n  let tx0 = new Transaction();\n  tx0.add(...createSptIx, ...createVaultIx, ...createVaultStakeIx, ...createVaultPwIx);\n  let signers0 = [spt, vault, vaultStake, vaultPw];\n  const tx = {\n    tx: tx0,\n    signers: signers0\n  };\n  return [tx, {\n    spt: spt.publicKey,\n    vault: vault.publicKey,\n    vaultStake: vaultStake.publicKey,\n    vaultPw: vaultPw.publicKey\n  }];\n} // Returns all events in the reward queue.\n\nexport function rewardEvents(rewardQ) {\n  let events = [];\n  let tail = rewardQ.tail;\n\n  while (tail < rewardQ.head) {\n    let idx = tail % rewardQ.events.length;\n    events.push(rewardQ.events[idx]);\n    tail += 1;\n  }\n\n  return events;\n}","map":{"version":3,"sources":["F:/jobs/stake_in_solana/source/src/utils/registry.ts"],"names":["Transaction","Account","serumCmn","anchor","registrarSigner","programId","registrar","publicKey","nonce","web3","PublicKey","findProgramAddress","toBuffer","memberSigner","member","vendorSigner","vendor","memberSeed","console","log","seed","utils","sha256","toString","slice","createBalanceSandbox","provider","r","registrySigner","spt","vault","vaultStake","vaultPw","lamports","connection","getMinimumBalanceForRentExemption","createSptIx","createTokenAccountInstrs","poolMint","createVaultIx","mint","createVaultStakeIx","createVaultPwIx","tx0","add","signers0","tx","signers","rewardEvents","rewardQ","events","tail","head","idx","length","push"],"mappings":"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","sourcesContent":["import { Transaction, PublicKey, Account } from '@solana/web3.js';\nimport * as serumCmn from '@project-serum/common';\nimport * as anchor from '@project-serum/anchor';\n\nexport async function registrarSigner(\n  programId: PublicKey,\n  registrar: PublicKey,\n): Promise<{ publicKey: PublicKey; nonce: number }> {\n  const [publicKey, nonce] = await anchor.web3.PublicKey.findProgramAddress(\n    [registrar.toBuffer()],\n    programId,\n  );\n  return {\n    publicKey,\n    nonce,\n  };\n}\n\nexport async function memberSigner(\n  programId: PublicKey,\n  registrar: PublicKey,\n  member: PublicKey,\n): Promise<{ publicKey: PublicKey; nonce: number }> {\n  const [publicKey, nonce] = await anchor.web3.PublicKey.findProgramAddress(\n    [registrar.toBuffer(), member.toBuffer()],\n    programId,\n  );\n  return {\n    publicKey,\n    nonce,\n  };\n}\n\nexport async function vendorSigner(\n  programId: PublicKey,\n  registrar: PublicKey,\n  vendor: PublicKey,\n): Promise<{ publicKey: PublicKey; nonce: number }> {\n  const [publicKey, nonce] = await anchor.web3.PublicKey.findProgramAddress(\n    [registrar.toBuffer(), vendor.toBuffer()],\n    programId,\n  );\n  return {\n    publicKey,\n    nonce,\n  };\n}\n\n// Returns the seed used to derive a member address. This is not necessary, but\n// a UX convenience. Each member address is a deterministic function of the\n// program, beneficiary, and this (constant) seed.\nexport async function memberSeed(registrar: PublicKey): Promise<string> {\n  console.log(registrar, \"temple 1\");\n  const seed = await anchor.utils.sha256(`${registrar.toString()}:Member`);\n  // The max length of seeds allowed by Solana is 32.\n  return seed.slice(0, 32);\n}\n\n// Creates all the SPL otken vaults needed for constructing a `Member` account.\nexport async function createBalanceSandbox(\n  provider: serumCmn.Provider,\n  r: any,\n  registrySigner: PublicKey,\n) {\n  const spt = new Account();\n  const vault = new Account();\n  const vaultStake = new Account();\n  const vaultPw = new Account();\n\n  const lamports = await provider.connection.getMinimumBalanceForRentExemption(\n    165,\n  );\n\n  const createSptIx = await serumCmn.createTokenAccountInstrs(\n    provider,\n    spt.publicKey,\n    r.poolMint,\n    registrySigner,\n    lamports,\n  );\n  const createVaultIx = await serumCmn.createTokenAccountInstrs(\n    provider,\n    vault.publicKey,\n    r.mint,\n    registrySigner,\n    lamports,\n  );\n  const createVaultStakeIx = await serumCmn.createTokenAccountInstrs(\n    provider,\n    vaultStake.publicKey,\n    r.mint,\n    registrySigner,\n    lamports,\n  );\n  const createVaultPwIx = await serumCmn.createTokenAccountInstrs(\n    provider,\n    vaultPw.publicKey,\n    r.mint,\n    registrySigner,\n    lamports,\n  );\n  let tx0 = new Transaction();\n  tx0.add(\n    ...createSptIx,\n    ...createVaultIx,\n    ...createVaultStakeIx,\n    ...createVaultPwIx,\n  );\n  let signers0 = [spt, vault, vaultStake, vaultPw];\n\n  const tx = { tx: tx0, signers: signers0 };\n\n  return [\n    tx,\n    {\n      spt: spt.publicKey,\n      vault: vault.publicKey,\n      vaultStake: vaultStake.publicKey,\n      vaultPw: vaultPw.publicKey,\n    },\n  ];\n}\n\n// Returns all events in the reward queue.\nexport function rewardEvents(rewardQ: any): any[] {\n  let events = [];\n  let tail = rewardQ.tail;\n  while (tail < rewardQ.head) {\n    let idx = tail % rewardQ.events.length;\n    events.push(rewardQ.events[idx]);\n    tail += 1;\n  }\n  return events;\n}\n"]},"metadata":{},"sourceType":"module"}